<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android 性能优化总结</title>
      <link href="/android-note/2021/04/13/android_performance/android_performance_all_in_one/"/>
      <url>/android-note/2021/04/13/android_performance/android_performance_all_in_one/</url>
      
        <content type="html"><![CDATA[<p>性能的优化是一个老生常谈的点，也是一个比较重要的点。做过一点性能优化的工作，现在对工作中的优化点做一个总结。如有错误，还请指正。</p><h1 id="有哪些方面需要优化"><a href="#有哪些方面需要优化" class="headerlink" title="有哪些方面需要优化"></a>有哪些方面需要优化</h1><p>在平时的优化过程中我们需要从哪几个点来优化呢？其实我们平时自己一定也用过软件，在使用软件的过程中有没有什么想吐槽的呢？</p><p>“这个 app 怎么还没下载完！”、“太卡了吧！”、”图片怎么还没加载出来！”、”怎么刚进去就卡了！”、“这么点了一下就退出了！”等等，是不是有这样的想法？这些想法其实包含了我们今天要说的内容，就是从哪些方面来优化我们的 APP ，我总结了以下几点。</p><ul><li>APK 瘦身优化</li><li>启动速度优化</li><li>稳定性优化 </li><li>内存的优化 </li><li>操作流畅度优化 </li></ul><p>当然，需要优化的不仅仅是这几个方面，我做的比较多的优化是这几个方面，暂时就这几个方面来谈谈优化吧。</p><h1 id="APK-瘦身"><a href="#APK-瘦身" class="headerlink" title="APK 瘦身"></a>APK 瘦身</h1><h2 id="如何查看-APK-的组成"><a href="#如何查看-APK-的组成" class="headerlink" title="如何查看 APK 的组成"></a>如何查看 APK 的组成</h2><p>如果要优化 APK 的大小，我们首先需要知道我们编译出来的 APK 都包含哪些东西，然后针对占用大的做裁剪，或者删除不需要的东西，从而达到瘦身的目的。</p><p>查看 APK 的内容占用情况很简单，打开 AS ，把 APK 拖到 AS 里面就可以查看 APK 包含的内容了。</p><p><img src="https://img.imgdb.cn/item/607455ab8322e6675c0bab2c.jpg" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/607455ab8322e6675c0bab2c.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="资源预览"></p><p>可以看到占大头的是 res 代码等，所以瘦身可以从这几个方面来考虑。</p><h2 id="如何减少-res-资源大小"><a href="#如何减少-res-资源大小" class="headerlink" title="如何减少 res 资源大小"></a>如何减少 res 资源大小</h2><ol><li>删除冗余的资源</li></ol><p>一般随着项目的迭代，部分图片等资源不再使用了，但是可能仍然被编译到了 apk 里面，所以可以删除这部分不再使用的资源，可以使用 lint 工具来搜索项目中不再使用的图片等资源。</p><ol start="2"><li>重复资源的优化</li></ol><p>除了有冗余资源，还有些是文件名不一样，但是内容一样的图片，可以通过比较 md5 值来判断是不是一样的资源，然后编辑 resources.arsc 来重定向。</p><ol start="3"><li>图片压缩</li></ol><p>未压缩的图片文件占用空间较大，可以考虑压缩未压缩过的图片来瘦身。常用的工具是  <a href="https://tinypng.com/">tinypng</a> 网站。</p><p>同时也可以借助 <a href="https://github.com/Deemonser/TinyPngPlugin">TinyPngPlugin</a> 等插件或者其他开源工具来帮助压缩图片。</p><ol start="4"><li>资源混淆</li></ol><p>通过将资源路径 <code>res/drawable/wechat</code> 变为 <code>r/d/a</code> 的方式来减少 apk 的大小，当 apk 有较多资源项的时候，效果比较明显，这是一款微信开源的工具，详细地址是：<a href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a></p><ol start="5"><li>指定语言</li></ol><p>如果没有特殊的需求的话，可以只编译中文，因为其他的语言用不上，如果用不上的语言编译了，会在 resource 的表里面占用大量的空间，故</p><pre><code>android &#123;    defaultConfig &#123;        ...        // 仅支持 中文        resConfigs &quot;zh&quot;     &#125;&#125;</code></pre><h2 id="如何减少-so-库资源大小"><a href="#如何减少-so-库资源大小" class="headerlink" title="如何减少 so 库资源大小"></a>如何减少 so 库资源大小</h2><ol><li>自己编译的 so </li></ol><p>release 包的  so 中移除调试符号。可以使用 Android NDK 中提供的 <code>arm-eabi-strip</code> 工具从原生库中移除不必要的调试符号。</p><p>如果是 cmake 来编译的话，可以再编辑脚本添加如下代码</p><pre><code>set(CMAKE_C_FLAGS_RELEASE &quot;$&#123;CMAKE_C_FLAGS_RELEASE&#125; -s&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -s&quot;)</code></pre><ol start="2"><li>别人编译的 so</li></ol><p>联系作者修改，一般很难联系到。</p><ol start="3"><li>动态下发 so</li></ol><p>可以通过服务器下发 so , 下载完后再进入应用，但是体验不好，但是是一个思路。</p><ol start="4"><li>只编译指定平台的 so </li></ol><p>一般我们都是给 arm 平台的机器开发，如果没有特殊情况，我们一般只需要考虑 arm 平台的。具体的方法是 app 下的 build.gradle 添加如下代码</p><pre><code>android &#123;    defaultConfig &#123;        ndk &#123;            abiFilter &quot;armeabi&quot;        &#125;    &#125;&#125;</code></pre><p>各个平台的差别如下：</p><table><thead><tr><th>平台</th><th>说明</th></tr></thead><tbody><tr><td>armeabi-v7a</td><td>arm 第 7 代及以上的处理器，2011 年后的设备基本都是</td></tr><tr><td>arm64-v8a</td><td>arm 第 8 代 64 位处理器设备</td></tr><tr><td>armeabi</td><td>arm 第 5、6 代处理器，早期的机器都是这个平台</td></tr><tr><td>x86</td><td>x86 32 位平台，平板和模拟器用的多</td></tr><tr><td>x86_64</td><td>x86 64 位平台</td></tr></tbody></table><h2 id="如何减少代码资源大小"><a href="#如何减少代码资源大小" class="headerlink" title="如何减少代码资源大小"></a>如何减少代码资源大小</h2><ol><li>一个功能尽量用一个库</li></ol><p>比如加载图片库，不要 glide 和 fresco 混用，因为功能是类似的，只是使用的方法不一样，用了多个库来做类似的事情，代码肯定就变多了。</p><ol start="2"><li>混淆</li></ol><p>混淆的话，减少了生成的 class 大小，这样积少成多，也可以从一定层度减少 apk 的大小。</p><ol start="3"><li>R 文件内联</li></ol><p>通过把 R 文件里面的资源内联到代码中，从而减少 R 文件的大小。</p><p>可以使用 <a href="https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/README-zh.md">shrink-r-plugin</a> 工具来做 R 文件的内联</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html">Android App包瘦身优化实践</a></p><h1 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h1><h2 id="启动的类型"><a href="#启动的类型" class="headerlink" title="启动的类型"></a>启动的类型</h2><p>一般分为，冷启动和热启动</p><blockquote><p>冷启动：启动时，后台没有任何该应用的进程，系统需要重新创建一个进程，并结合启动参数启动该应用。</p></blockquote><blockquote><p>热启动：启动时，系统已经有该应用的进程(比如按 home 键临时退出该应用)下启动该应用。</p></blockquote><h2 id="如何获取启动时间"><a href="#如何获取启动时间" class="headerlink" title="如何获取启动时间"></a>如何获取启动时间</h2><ol><li>adb 命令</li></ol><p>adb shell am start -S -W 包名/启动类的全名</p><pre><code>adb shell am start -S -W xxx/xxxActivityStopping: xxxStarting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=xxx/xxxActivity &#125;Status: okActivity: xxx/xxxActivityThisTime: 770TotalTime: 770WaitTime: 848Complete</code></pre><p><strong>ThisTime</strong>: 表示最后一个 Activity 启动时间</p><p><strong>TotalTime</strong>: 表示启动过程中，所有的 Activity 的启动时间</p><p><strong>WaitTime</strong>: 表示应用进程的创建时间 + TotalTime</p><p>一般我们关注 <code>TotalTime</code> 就好了。</p><p>另外，谷歌在 Android4.4（API 19）上也提供了测量方法，在 logcat 中过滤 Displayed 字段也可以看到启动时间</p><blockquote><p>2021-04-06 19:25:52.803 2210-2245 I/ActivityManager: Displayed xxx/xxxActivity: +623ms</p></blockquote><p><code>+623ms</code> 就是Activity 的启动时间。</p><ol start="2"><li>时间戳</li></ol><p>时间戳的方法基于以下的 2 个知识点。</p><ul><li>应用进程刚创建，会调用 Application 的 onCreate 方法。</li><li>首次进入一个 Activity 后会在 onResume() 方法后面调用 onWindowsFocusChange 方法。</li></ul><p>结合这 2 个特性，我们可以在<br>A<br>Application 的 onCreate() 方法和 Activity 的 onWindowsFocusChange 方法里面，通过时间戳来获取应用的冷启动时间。</p><h2 id="如何监控启动过程"><a href="#如何监控启动过程" class="headerlink" title="如何监控启动过程"></a>如何监控启动过程</h2><ol><li>systrace</li></ol><p>systrace 是一个功能很强大的工具，除了可以查看卡顿问题，也可以用来查看应用的启动问题。使用示例如下：</p><blockquote><p>python $ANDROID_HOME/platform-tools/systrace/systrace.py gfx view wm am pm ss dalvik app sched -b 90960 -a 你的包名 -o test.log.html</p></blockquote><p>用 Google  浏览器打开 <code>test.log.html</code> 就可以看到详细的启动信息。</p><ol start="2"><li>Debug 接口</li></ol><pre><code>package android.os;...class Debug &#123;    ...    public static void startMethodTracingSampling(String tracePath, int bufferSize, int intervalUs) &#123;    &#125;    public static void startMethodTracing(String tracePath, int bufferSize) &#123;    &#125;&#125;</code></pre><p>利用 Debug 类的这两个方法，可以生成一个 <code>trace</code> 文件，这个 <code>trace</code> 文件，可以直接在 <code>AS</code> 里面打开，可以看到从 <code>startMethodTracingSampling</code> 到 <code>startMethodTracing</code> 过程中的方法调用等信息，也可以较好的分析启动问题。</p><h2 id="一般有那些优化方法"><a href="#一般有那些优化方法" class="headerlink" title="一般有那些优化方法"></a>一般有那些优化方法</h2><ol><li>耗时操作放到异步进程</li></ol><p>比如文件解压、读写等耗时 IO 操作可以新开一个线程来执行。</p><ol start="2"><li>延时初始化</li></ol><p>即暂时不适用的工具类等延后到使用的时候再去初始化。比如从 xml 里面读取颜色，可以考虑在使用的时候再去读取和解析。</p><ol start="3"><li>线程优化</li></ol><p>线程的创建需要消耗较多的系统系统资源，减少线程的创建。可以考虑共用一个线程池。</p><p>如何检测线程的创建，可以参考我个开源库 <a href="https://github.com/XanderWang/performance">performance</a></p><h1 id="稳定性优化"><a href="#稳定性优化" class="headerlink" title="稳定性优化"></a>稳定性优化</h1><h2 id="APP-稳定性的维度"><a href="#APP-稳定性的维度" class="headerlink" title="APP 稳定性的维度"></a>APP 稳定性的维度</h2><p>app 稳定一般指的是 app 能正常运行， app 不能正常运行的情况分为两大类，分别是 <code>Crash</code> 和 <code>ANR</code></p><blockquote><p>Crash：运行过程中发生的错误，是无法避免的。</p></blockquote><blockquote><p>ANR：应用再运行时，由于无法再规定的时间段内响应完，系统做出的一个操作。</p></blockquote><h2 id="如何治理-Crash"><a href="#如何治理-Crash" class="headerlink" title="如何治理 Crash"></a>如何治理 <code>Crash</code></h2><p>应用发生 Crash 是由于应用在运行时，应用产生了一个未处理的异常(就是没有被 try catch 捕获的异常)。这会导致 app 无法正常运行。</p><p>如果需要解决的话，就需要知道这个未处理的异常是在哪里产生的，一般是通过分析未处理的异常的方法调用堆栈来解决问题。</p><p>Android APP 可以分为 2 层，Java 层和 Native 层。所以如何捕获需要分开说。</p><h3 id="Java-层获取未处理的异常的调用堆栈"><a href="#Java-层获取未处理的异常的调用堆栈" class="headerlink" title="Java 层获取未处理的异常的调用堆栈"></a>Java 层获取未处理的异常的调用堆栈</h3><p>这个需要了解 <code>Java</code> 虚拟机是如何把一个未捕获的异常报上来的。</p><p>未捕获的异常，会沿着方法的调用链依次上抛，直到 <code>ThreadGroup</code> 的 <code>uncaughtException</code> 方法</p><pre><code class="java">    public void uncaughtException(Thread t, Throwable e) &#123;        if (parent != null) &#123;            // 递归调用，可以忽略            parent.uncaughtException(t, e);         &#125; else &#123;            // 交给了 Thread.getDefaultUncaughtExceptionHandler() 来处理未捕获的异常            Thread.UncaughtExceptionHandler ueh =                Thread.getDefaultUncaughtExceptionHandler();            if (ueh != null) &#123;                ueh.uncaughtException(t, e);            &#125; else if (!(e instanceof ThreadDeath)) &#123;                System.err.print(&quot;Exception in thread \&quot;&quot;                                 + t.getName() + &quot;\&quot; &quot;);                e.printStackTrace(System.err);            &#125;        &#125;    &#125;</code></pre><p>查阅代码发现，发现 <code>ThreadGroup</code> 最终会给 <code>Thread</code> 的 <code>defaultUncaughtExceptionHandler</code> 处理。</p><pre><code class="java">private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;</code></pre><p> 上面的代码显示：<code>Thread</code> 的 <code>defaultUncaughtExceptionHandler</code> 是 <code>Thread</code> 类的一个静态变量。</p><p>看到这里，如何捕获 <code>Java</code> 层未处理的异常就很清晰了，给 <code>Thread</code> 设置一个<code>新的 defaultUncaughtExceptionHandler</code>，在这个新的<code> defaultUncaughtExceptionHandler</code> 里面收集需要的信息就可以了。</p><p>需要注意的一点是 <code>旧的 defaultUncaughtExceptionHandler</code> 需要保存下来，然后<code>新的 defaultUncaughtExceptionHandler</code> 收集信息后，需要再转给<code>旧的 defaultUncaughtExceptionHandler</code> 继续处理。</p><h3 id="Native-层获取未处理的异常的相关信息"><a href="#Native-层获取未处理的异常的相关信息" class="headerlink" title="Native 层获取未处理的异常的相关信息"></a>Native 层获取未处理的异常的相关信息</h3><p>Java 层如何收集未处理的异常的信息说过了，我们来看看 Native 层发生未处理的异常的话，是如何处理的。 Native 层的处理，需要掌握 linux 的一些知识，由于本人不是特别了解 linux ，这里就直接参考别人的文章了。如果有错误，还请指正。</p><p>本人通过查阅资料发现，Native 层如果发生未处理的异常(注:如果 Native 层捕获了异常，是可以通过 JNI 抛到 Java 层去处理的) ，系统会发出信号给 Native 层，在 Native 层如果要收集未处理的异常信息，就需要注册对应信号的处理函数。当发生异常的时候，Native 层会收到信息，然后通过处理器来收集信息。</p><p>注册信号处理函数如下：</p><pre><code class="c">#include &lt;signal.h&gt; int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</code></pre><ul><li>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</li><li>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</li><li>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</li></ul><p>有了信号处理函数，后面还要做的事情就是收集信息了，由于本人不是很熟悉 Native 的开发，这里就不展开说了了，大家可以参考 <a href="https://www.cnblogs.com/mingfeng002/p/9118253.html">Android 平台 Native 代码的崩溃捕获机制及实现</a>。</p><h2 id="如何治理-ANR"><a href="#如何治理-ANR" class="headerlink" title="如何治理 ANR"></a>如何治理 <code>ANR</code></h2><p><code>ANR</code> 是 <code>Applicatipon No Response</code> 的简称。如果应用卡死或者响应过慢，系统就会杀死应用。为什么要杀死应用？其实也很好理解，如果不杀死应用，大家会以为系统坏了。</p><p>那我们如何监控 <code>ANR</code> 呢？以及我们如何分析 ANR 的问题呢？常见的导致 ANR 的原因有哪些呢？</p><p>首先，<code>ANR</code> 的原理是 <code>AMS</code> 在 <code>UI 操作</code>开始的时候，会根据 <code>UI 操作</code>的类型开启一个延时任务，如果这个任务被触发了，就表示应用卡死或者响应过慢。这个任务会在 <code>UI 操作</code>结束的时候被移除。</p><p>然后，如何分析 <code>ANR</code> 问题呢？</p><p>一般 <code>ANR</code> 发生的时候， <code>logcat</code> 里面会打印 <code>ANR</code> 相关的信息，过滤关键字 <code>ANR</code> 就可以看到，这里不做详细分析，可以参考后面的文章。</p><p>然后一般会在 <code>/data/anr</code> 目录下面生成 <code>traces.txt</code> 文件，里面一般包含了 <code>ANR</code> 发生的时候，系统和所有应用的线程等信息(需要注意的是，不同的 rom 可能都不一样)，通过 <code>logcat</code> 打印的信息和 <code>traces.txt</code> 里面的信息，大部分的 <code>ANR</code> 可以分析出原因，但是呢，也有相当一部分的 ANR 问题无法分析，因为 <code>logcat</code> 和 <code>traces.txt</code> 提供的信息有限，有时候甚至没有特别有用的信息，特别是 <code>Android</code> 的权限收紧， <code>traces.txt</code> 文件在<code>高 Android 版本</code>无法读取，给 <code>ANR</code> 问题的分析增加了不少的困难。不过好在最近发现头条给 <code>ANR</code> 写了一个系列的文章，里面对 ANR 问题的治理方法，个人觉得很好，这里引用一下。</p><ul><li><a href="https://mp.weixin.qq.com/s/ApNSEWxQdM19QoCNijagtg">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li><li><a href="https://mp.weixin.qq.com/s/_Z6GdGRVWq-_JXf5Fs6fsw">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a></li><li><a href="https://mp.weixin.qq.com/s/4-_SnG4dfjMnkrb3rhgUag">今日头条 ANR 优化实践系列分享 - 实例剖析集锦</a></li><li><a href="https://mp.weixin.qq.com/s/OBYWrUBkWwV8o6ChSVaCvw">今日头条 ANR 优化实践系列 - Barrier 导致主线程假死</a></li></ul><p>本人之前写过一个小的<a href="https://github.com/XanderWang/performance">性能监测的工具</a>，其中有监控 <code>UI</code> 线程 <code>Block</code> 的功能，考虑后续加入头条的 <code>ANR</code> 监测机制，等后续完成了，在做一个详细的总结吧。这次的总结就写到这里。</p><h1 id="内存的优化"><a href="#内存的优化" class="headerlink" title="内存的优化"></a>内存的优化</h1><p>硬件的内存总是有限的，所有每个应用分到的内存也是有限的，所有内存的优化很有必要，否则应用就没有足够的内存使用了，这个时候就会 Crash 。</p><h2 id="内存都消耗在哪里了"><a href="#内存都消耗在哪里了" class="headerlink" title="内存都消耗在哪里了"></a>内存都消耗在哪里了</h2><p>优化内存的话，需要了解内存在哪里消耗了了，针对内存消耗大的场景做优化，对症下药，才可以有一个好的优化效果。</p><p><code>Android Studio</code> 里面的 <code>Profiler</code> 工具是一个很好用的工具，通过里面的 <code>memory</code> 工具可以<code>实时监控</code> APP 运行过程中的内存分配。</p><p><img src="https://img.imgdb.cn/item/60742b578322e6675cac02b9.jpg" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/60742b578322e6675cac02b9.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="内存性能分析器"></p><p>dump APP 内存堆栈后，还可以看到各个类占用的内存情况。</p><p><img src="https://img.imgdb.cn/item/60742b928322e6675cac8841.jpg" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/60742b928322e6675cac8841.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="有关每个已分配对象的详细信息显示在右侧的 Instance View 中"></p><p>可以查看每个对象的详细信息。</p><p><code>Android Studio</code> 里面的 <code>Profiler</code> 工具的具体使用教程请参考<a href="https://developer.android.google.cn/studio/profile/memory-profiler?hl=zh-cn">官方教程</a>，这里就不做详细介绍了。</p><h2 id="如何合理使用内存"><a href="#如何合理使用内存" class="headerlink" title="如何合理使用内存"></a>如何合理使用内存</h2><p>利用上面的方法，找到内存消耗大的场景，就需要做优化了，主要做法就是想办法减少特定场景下的内存的使用。个人总结了一下平时可能会做的优化。</p><ul><li>图片相关的优化</li></ul><p>图片是我目前做的应用里面占用内存比较大的一块了，也碰到了一些问题，我主要是通过以下的方法来做优化。</p><ol><li>暂时用不上的图片不加载，比如说，有个网络加载异常的图，不要一开始就初始化，等到真的有异常了需要展示的时候再初始化</li><li>加载图片的时候，尽量加载指定大小的图片，因为有时候会碰到控件的大小小于实际图片尺寸的情况，这个时候，会浪费一些内存。有需要的话，可以让后台返回不同尺寸的图片。</li><li>根据不同的图片格式</li><li>不显示的图片，可以考虑先释放。</li></ol><ul><li>尽可能少地创建对象</li></ul><p>毫无疑问，如果对象少，内存肯定也消耗的少，那平时需要注意哪些呢？</p><ol><li>自定义 view 的时候，不要在 onDraw 方法里面频繁创建对象。因为 onDraw 方法可能会频繁调用，这个时候就会创建大量的对象。从而造成浪费，同时也会导致 gc 触发的频率升高，造成卡顿。</li><li>尽量少创建线程，创建线程其实是比较消耗资源的，创建一个空的线程，大概会占用 1-2 M 内存。同时一般异步任务很快就会执行完，如果频繁创建线程来做异步任务，除了内存使用的多，还可能 GC 造成卡顿。执行异步任务的话，一般建议用线程池来执行，但是需要注意线程池的使用。</li><li>尽量用 StringBuilder 或者 StringBuffer 来拼接字符串。平时发现的问题主要是在打印 logcat 的时候和拼接后台返回的数据的时候会创建大量的 String，所以如果有类似的情况也可以考虑做一些优化。</li></ol><h2 id="内存泄漏是什么"><a href="#内存泄漏是什么" class="headerlink" title="内存泄漏是什么"></a>内存泄漏是什么</h2><p>内存泄漏指的是本应该释放的内存，由于一些原因，被 GC ROOT 对象持有，从而而无法在 GC 的时候释放，这样可能会导致的一个问题就是，重复操作以后，APP 没有足有的内存使用了，这个时候系统会杀死 APP 。所以内存泄漏是需要排查的。</p><h2 id="如何监控和分析内存泄漏问题"><a href="#如何监控和分析内存泄漏问题" class="headerlink" title="如何监控和分析内存泄漏问题"></a>如何监控和分析内存泄漏问题</h2><p>上一个小结总结了上面是内存泄漏，是因为某些 GC ROOT 对象持有了期望释放的对象，导致期望释放的内存无法及时释放。所以如何监控和分析内存泄漏问题就成了如何找到 GC ROOT 的问题。</p><p>一般手动分析的步骤是：重复操作怀疑有内存泄漏的场景，然后触发几次 GC 。等几秒钟后，把 APP 的内存堆栈 dump 下来(可以使用 as 的工具 dump)，然后用 sdk 里面的 cover 工具转换一下，然后用 MAT 工具来分析内存泄漏的对象到 GC ROOT 的引用链。</p><p>手动分析总是很麻烦的，一个好消息是，有一个特别好用的自动监控和分析内存泄漏的工具，这个工具就是 leakcanary ，它可以自动监控并给出内存泄漏的对象到 GC ROOT 的引用链。</p><p>使用很简单，只需要在 APP  的 build.gradle 下面新增</p><pre><code>dependencies &#123;  // debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.7&#39;&#125;</code></pre><p>leakcanary 比较核心的一个原理就是利用了弱引用的一个特性，这个特性就是：</p><blockquote><p>在创建弱引用的时候，可以指定一个 RefrenceQueue ，当弱引用引用的对象的可达性发生变化的时候，系统会把这个弱引用引用的对象放到之前指定的 RefrenceQueue 中等待处理。</p></blockquote><p>所以 GC 后，引用对象仍然没有出现在 RefrenceQueue 的时候，说明可能发生了内存泄漏，这个时候 leakcanary 就会 dump 应用的 heap ，然后用 shark 库分析 heap ，找出一个到 GC ROOT 的最短引用链并提示。</p><h2 id="常见的内存泄漏的场景"><a href="#常见的内存泄漏的场景" class="headerlink" title="常见的内存泄漏的场景"></a>常见的内存泄漏的场景</h2><p>个人总结了下工作中碰到内存泄漏的一些场景，现记录下来，大家可以参考下。</p><ol><li>静态变量持有 Context 等。</li><li>单例实例持有 Context 等。</li><li>一些回调没有反注册，比如广播的注册和反注册等，有时候一些第三方库也需要注意。</li><li>一些 Listener 没有手动断开连接。</li><li>匿名内部类持有外部类的实例。比如 Handler , Runnable 等常见的用匿名内部类的实现，常常会不小心持有 Context 等外部类实例。</li></ol><h1 id="操作流畅度优化"><a href="#操作流畅度优化" class="headerlink" title="操作流畅度优化"></a>操作流畅度优化</h1><h2 id="为什么会卡顿"><a href="#为什么会卡顿" class="headerlink" title="为什么会卡顿"></a>为什么会卡顿</h2><p>为什么卡顿之前，我们先需要简单了解一点硬件相关的知识。就是在界面绘制的过程中， CPU 主要的任务是计算出屏幕上所有 View 对应的图形和向量等信息。 GPU 的主要任务就是把 CPU 计算出的图形栅格化并转化为位图，可以简单理解为屏幕像素点对应的值。</p><p>如果操作过程中卡顿了，一般就是 CPU 和 GPU 其中的一个或者多个无法短时间完成对应的任务。</p><p>一般而言，CPU 除了需要计算 View 对应的图形和向量等信息，还要做逻辑运算和文件读写等任务，所以 CPU 造成卡顿更常见。一般也是通过减少 CPU 的计算任务来优化卡顿。</p><p>影响 CPU 的使用率一般有以下几个方面：</p><ul><li>读写文件</li><li>解析大量图片</li><li>频繁请求网络</li><li>复杂的布局</li><li>频繁创建对象 </li></ul><h2 id="如何检测卡顿"><a href="#如何检测卡顿" class="headerlink" title="如何检测卡顿"></a>如何检测卡顿</h2><p>虽然我们知道了大概哪些原因会导致卡顿，但是我们无法准确定位出问题的代码点在哪里，针对上面的部分问题，本人写了一个开源库来自动检测，这个开源库的地址是</p><blockquote><p><a href="https://github.com/XanderWang/performance">https://github.com/XanderWang/performance</a></p></blockquote><p>详细的原理，可以参考上面的连接，这里简单总结下监控 UI 卡段的原理。</p><p>我们知道，<code>Android</code> 里面，界面的刷新需要再主线程或者说 UI 线程执行。而界面的绘制起始点又利用了 <code>Looper 消息循环</code>机制。<code>Looper 消息循环</code>机制有一个有意思的特点，就是 Looper 在 <code>dispatch</code> Message 的时候，会在 <code>dispatch 前</code>和 <code>dispatch 后</code>利用 <code>Printer</code> 打印<code>特定 tag</code> 的字符串，通过<code>接管 Printer</code> ，我们就可以获取 <code>dispatch message</code> 前后的时机。</p><p>然后我们可以在 <code>dispatch message 之前</code>，在<code>异步线程</code>启动一个抓取系统信息的延时任务。在 <code>dispatch message 之后</code>，我们可以<code>移除</code>异步线程的这个延时任务。如果某个消息的执行没有超过阈值，那就表示在异步线程的延时任务被取消，表明没有卡顿。如果某个消息的执行时间超过了阈值，那异步线程里的延时任务就会执行，表明有卡顿，异步线程的延时任务会获取此时的系统状态，从而辅助我们分析卡顿问题。</p><h2 id="如何优化卡顿"><a href="#如何优化卡顿" class="headerlink" title="如何优化卡顿"></a>如何优化卡顿</h2><p>如何检测说完了，我们来说说如何优化。在 为什么会卡顿 小结我总结了几种常见，现在对几种场景的优化总结下。</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>最常见的一个读写文件而不自知的就是 <code>SharePerfrences</code> 的使用，使用 <code>sp</code> 的时候需要注意不要频繁调用 <code>apply</code> 或者 <code>commit</code> 方法，因为每调用一次就有可能会有一次写文件操作(高版本系统做了优化 apply 做了优化，不一定会写文件)。所以，如果调用次数多的话，就会多次写文件，写文件又是一个耗时且耗资源的操作，所以要少做。</p><p>一般优化方法是合理<code>拆分</code> sp 文件，一个 sp 文件不要包含太多的项，同时每一项的内容尽量短。尽量批量提交数据后再 commit 或者 apply 。同时需要注意的是 commit 会直接触发写文件(内容有变化的时候)，所以如果在 UI 线程调用 commit 方法需要注意可能会阻塞 UI 线程。</p><p>如果有更高的性能需求，可以考虑用 <a href="https://github.com/Tencent/MMKV">mmkv</a> 来替换或者 <a href="https://developer.android.google.cn/topic/libraries/architecture/datastore?hl=zh-cn">DataStore</a> 来替换 sp 。具体的替换方法就不细说了。网上有很多资料参考。</p><p>另外一个常见的读写文件的场景是从 xml 文件里面读取布局、色值等操作，这些都是一些 io 操作。从 xml 读取布局的话，可以考虑用代码直接创建 view 来优化，从 xml 里面读取颜色可以考虑加个 HashMap 来优化。</p><h3 id="解析大量图片"><a href="#解析大量图片" class="headerlink" title="解析大量图片"></a>解析大量图片</h3><p>解码图片毫无疑问是一个计算量大的操作，所以一般加载图片的时候最好根据实际显示的尺寸做压缩，并且保存压缩后的缩略图，方便下次直接加载。</p><p>另外还需要注意列表滚动过程中，控制对图片的加载，一般列表在滑动过程中，不加载图片，等列表滚动停止后，才开始加载图片。</p><p>另外的一个优化的方法就是减少图片的使用，不过这个难度有点大。</p><p>另外还可以考虑针对不同的图片格式，用不同的解码格式。比如 <code>png</code> 格式的图片根据机器实际情况选择 <code>8888</code> 或者 <code>4444</code> 解码方式解码图片。如果是 <code>jpg/jpeg</code> 格式的图片，就用 <code>565</code> 的解码方式解码图片。对于用不同的解码方式解码图片，效率是否会高，本人没做过测试，但是毫无疑问，内存的使用是不同的。</p><h3 id="频繁请求网络"><a href="#频繁请求网络" class="headerlink" title="频繁请求网络"></a>频繁请求网络</h3><p>网络请求的话，可以参考下面的优化方法。</p><ol><li><p>如果使用 <code>okhttp</code> 请求网络的话，尽量全局使用一个 <code>httpclient</code> ，这样做的好处是可以复用，提高网络请求效率。</p></li><li><p>后台支持的话，开启 <code>gzip</code> 压缩，这样网络传输的数据量小些，传输效率会高些。</p></li><li><p>自定义 <code>dns</code> ，减少解析 <code>dns</code> 的时间。</p></li><li><p>通过和后台商量，部分数据后台接口一步到位，尽量避免多次请求后才拿到完整的目标数据。</p></li></ol><h3 id="复杂的布局"><a href="#复杂的布局" class="headerlink" title="复杂的布局"></a>复杂的布局</h3><p>如果布局复杂的话， CPU 要进行大量的计算才可以确定最终的图形。所以布局复杂的话，CPU 需要大量的运算资源，所以优化复杂的布局是很有必要的。</p><ol><li><p>减少布局层次，可以利用 ViewStub 、merge 和 include 等标签来尝试减少布局层次。</p></li><li><p>使用高效的布局容器，比如 ConstraintLayout，可以不用嵌套布局容器来实现复杂效果。</p></li><li><p>部分效果可以考虑用自定义 View 实现。</p></li></ol><p>这个优化感觉不是特别好做，可能优化了，但是效果不好，但是又不能不做。</p><h3 id="频繁创建对象"><a href="#频繁创建对象" class="headerlink" title="频繁创建对象"></a>频繁创建对象</h3><p>为什么这个要列出来呢？因为频繁创建对象，可能会短时间内消耗大量内存，然后内存不足的时候系统就会尝试 GC 来回收对象，而 GC 是很耗资源的操作，虽然现在 Android 系统对 GC 做了很多优化，但是尽量减少 GC 的触发总是好的。</p><p>一般频繁创建对象的场景有:</p><ul><li>自定义 View 的时候，在 onDraw 方法创建临时对象</li><li>循环里面使用 “+” 拼接字符串</li><li>ArrayList 等有容积限制的容器类初始化的容量不合理，导致后续新增数据频繁扩容。</li></ul><p>可能还有一些场景没有列出来，如果大家有好的建议，可以提出来。</p><p>除了频繁创建对象可能会触发 GC ，如果某次使用过大的内存也可能会导致 GC ，比如展示一个超大的 Bitmap ，虽然可以用缩略图来展示，但是可能会碰到需要放大查看具体细节的场景，这个时候可以考虑采用裁剪显示区域(BitmapRegionDecoder)的方式来解析图片。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上是我工作中涉及到的优化点，可能不是很全，也难免有遗漏。如果有错误和遗漏，还请大家指正。</p><h1 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h1><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#x34;&#50;&#48;&#54;&#x34;&#48;&#55;&#54;&#51;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#x34;&#50;&#48;&#54;&#x34;&#48;&#55;&#54;&#51;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化 - 操作流畅度优化</title>
      <link href="/android-note/2021/04/10/android_performance/android_performance_app_caton/"/>
      <url>/android-note/2021/04/10/android_performance/android_performance_app_caton/</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/android-note/2021/04/01/android_performance/android_performance_summary/" title="Android 性能优化概要">Android 性能优化概要</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a></li><li><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a></li></ul><h2 id="为什么会卡顿"><a href="#为什么会卡顿" class="headerlink" title="为什么会卡顿"></a>为什么会卡顿</h2><p>为什么卡顿之前，我们先需要简单了解一点硬件相关的知识。就是在界面绘制的过程中， CPU 主要的任务是计算出屏幕上所有 View 对应的图形和向量等信息。 GPU 的主要任务就是把 CPU 计算出的图形栅格化并转化为位图，可以简单理解为屏幕像素点对应的值。</p><p>如果操作过程中卡顿了，一般就是 CPU 和 GPU 其中的一个或者多个无法短时间完成对应的任务。</p><p>一般而言，CPU 除了需要计算 View 对应的图形和向量等信息，还要做逻辑运算和文件读写等任务，所以 CPU 造成卡顿更常见。一般也是通过减少 CPU 的计算任务来优化卡顿。</p><p>影响 CPU 的使用率一般有以下几个方面：</p><ul><li>读写文件</li><li>解析大量图片</li><li>频繁请求网络</li><li>复杂的布局</li><li>频繁创建对象 </li></ul><h2 id="如何检测卡顿"><a href="#如何检测卡顿" class="headerlink" title="如何检测卡顿"></a>如何检测卡顿</h2><p>虽然我们知道了大概哪些原因会导致卡顿，但是我们无法准确定位出问题的代码点在哪里，针对上面的部分问题，本人写了一个开源库来自动检测，这个开源库的地址是</p><blockquote><p><a href="https://github.com/XanderWang/performance">https://github.com/XanderWang/performance</a></p></blockquote><p>详细的原理，可以参考上面的连接，这里简单总结下监控 UI 卡段的原理。</p><p>我们知道，<code>Android</code> 里面，界面的刷新需要再主线程或者说 UI 线程执行。而界面的绘制起始点又利用了 <code>Looper 消息循环</code>机制。<code>Looper 消息循环</code>机制有一个有意思的特点，就是 Looper 在 <code>dispatch</code> Message 的时候，会在 <code>dispatch 前</code>和 <code>dispatch 后</code>利用 <code>Printer</code> 打印<code>特定 tag</code> 的字符串，通过<code>接管 Printer</code> ，我们就可以获取 <code>dispatch message</code> 前后的时机。</p><p>然后我们可以在 <code>dispatch message 之前</code>，在<code>异步线程</code>启动一个抓取系统信息的延时任务。在 <code>dispatch message 之后</code>，我们可以<code>移除</code>异步线程的这个延时任务。如果某个消息的执行没有超过阈值，那就表示在异步线程的延时任务被取消，表明没有卡顿。如果某个消息的执行时间超过了阈值，那异步线程里的延时任务就会执行，表明有卡顿，异步线程的延时任务会获取此时的系统状态，从而辅助我们分析卡顿问题。</p><h2 id="如何优化卡顿"><a href="#如何优化卡顿" class="headerlink" title="如何优化卡顿"></a>如何优化卡顿</h2><p>如何检测说完了，我们来说说如何优化。在 为什么会卡顿 小结我总结了几种常见，现在对几种场景的优化总结下。</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>最常见的一个读写文件而不自知的就是 <code>SharePerfrences</code> 的使用，使用 <code>sp</code> 的时候需要注意不要频繁调用 <code>apply</code> 或者 <code>commit</code> 方法，因为每调用一次就有可能会有一次写文件操作(高版本系统做了优化 apply 做了优化，不一定会写文件)。所以，如果调用次数多的话，就会多次写文件，写文件又是一个耗时且耗资源的操作，所以要少做。</p><p>一般优化方法是合理<code>拆分</code> sp 文件，一个 sp 文件不要包含太多的项，同时每一项的内容尽量短。尽量批量提交数据后再 commit 或者 apply 。同时需要注意的是 commit 会直接触发写文件(内容有变化的时候)，所以如果在 UI 线程调用 commit 方法需要注意可能会阻塞 UI 线程。</p><p>如果有更高的性能需求，可以考虑用 <a href="https://github.com/Tencent/MMKV">mmkv</a> 来替换或者 <a href="https://developer.android.google.cn/topic/libraries/architecture/datastore?hl=zh-cn">DataStore</a> 来替换 sp 。具体的替换方法就不细说了。网上有很多资料参考。</p><p>另外一个常见的读写文件的场景是从 xml 文件里面读取布局、色值等操作，这些都是一些 io 操作。从 xml 读取布局的话，可以考虑用代码直接创建 view 来优化，从 xml 里面读取颜色可以考虑加个 HashMap 来优化。</p><h3 id="解析大量图片"><a href="#解析大量图片" class="headerlink" title="解析大量图片"></a>解析大量图片</h3><p>解码图片毫无疑问是一个计算量大的操作，所以一般加载图片的时候最好根据实际显示的尺寸做压缩，并且保存压缩后的缩略图，方便下次直接加载。</p><p>另外还需要注意列表滚动过程中，控制对图片的加载，一般列表在滑动过程中，不加载图片，等列表滚动停止后，才开始加载图片。</p><p>另外的一个优化的方法就是减少图片的使用，不过这个难度有点大。</p><p>另外还可以考虑针对不同的图片格式，用不同的解码格式。比如 <code>png</code> 格式的图片根据机器实际情况选择 <code>8888</code> 或者 <code>4444</code> 解码方式解码图片。如果是 <code>jpg/jpeg</code> 格式的图片，就用 <code>565</code> 的解码方式解码图片。对于用不同的解码方式解码图片，效率是否会高，本人没做过测试，但是毫无疑问，内存的使用是不同的。</p><h3 id="频繁请求网络"><a href="#频繁请求网络" class="headerlink" title="频繁请求网络"></a>频繁请求网络</h3><p>网络请求的话，可以参考下面的优化方法。</p><ol><li><p>如果使用 <code>okhttp</code> 请求网络的话，尽量全局使用一个 <code>httpclient</code> ，这样做的好处是可以复用，提高网络请求效率。</p></li><li><p>后台支持的话，开启 <code>gzip</code> 压缩，这样网络传输的数据量小些，传输效率会高些。</p></li><li><p>自定义 <code>dns</code> ，减少解析 <code>dns</code> 的时间。</p></li><li><p>通过和后台商量，部分数据后台接口一步到位，尽量避免多次请求后才拿到完整的目标数据。</p></li></ol><h3 id="复杂的布局"><a href="#复杂的布局" class="headerlink" title="复杂的布局"></a>复杂的布局</h3><p>如果布局复杂的话， CPU 要进行大量的计算才可以确定最终的图形。所以布局复杂的话，CPU 需要大量的运算资源，所以优化复杂的布局是很有必要的。</p><ol><li><p>减少布局层次，可以利用 ViewStub 、merge 和 include 等标签来尝试减少布局层次。</p></li><li><p>使用高效的布局容器，比如 ConstraintLayout，可以不用嵌套布局容器来实现复杂效果。</p></li><li><p>部分效果可以考虑用自定义 View 实现。</p></li></ol><p>这个优化感觉不是特别好做，可能优化了，但是效果不好，但是又不能不做。</p><h3 id="频繁创建对象"><a href="#频繁创建对象" class="headerlink" title="频繁创建对象"></a>频繁创建对象</h3><p>为什么这个要列出来呢？因为频繁创建对象，可能会短时间内消耗大量内存，然后内存不足的时候系统就会尝试 GC 来回收对象，而 GC 是很耗资源的操作，虽然现在 Android 系统对 GC 做了很多优化，但是尽量减少 GC 的触发总是好的。</p><p>一般频繁创建对象的场景有:</p><ul><li>自定义 View 的时候，在 onDraw 方法创建临时对象</li><li>循环里面使用 “+” 拼接字符串</li><li>ArrayList 等有容积限制的容器类初始化的容量不合理，导致后续新增数据频繁扩容。</li></ul><p>可能还有一些场景没有列出来，如果大家有好的建议，可以提出来。</p><p>除了频繁创建对象可能会触发 GC ，如果某次使用过大的内存也可能会导致 GC ，比如展示一个超大的 Bitmap ，虽然可以用缩略图来展示，但是可能会碰到需要放大查看具体细节的场景，这个时候可以考虑采用裁剪显示区域(BitmapRegionDecoder)的方式来解析图片。</p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#52;&#50;&#48;&#x36;&#52;&#x30;&#x37;&#x36;&#x33;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#52;&#50;&#48;&#x36;&#52;&#x30;&#x37;&#x36;&#x33;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> 操作流畅度优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化 - 内存优化</title>
      <link href="/android-note/2021/04/10/android_performance/android_performance_app_memory/"/>
      <url>/android-note/2021/04/10/android_performance/android_performance_app_memory/</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/android-note/2021/04/01/android_performance/android_performance_summary/" title="Android 性能优化概要">Android 性能优化概要</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a></li><li><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a></li></ul><p>硬件的内存总是有限的，所有每个应用分到的内存也是有限的，所有内存的优化很有必要，否则应用就没有足够的内存使用了，这个时候就会 Crash 。</p><h2 id="内存都消耗在哪里了"><a href="#内存都消耗在哪里了" class="headerlink" title="内存都消耗在哪里了"></a>内存都消耗在哪里了</h2><p>优化内存的话，需要了解内存在哪里消耗了了，针对内存消耗大的场景做优化，对症下药，才可以有一个好的优化效果。</p><p><code>Android Studio</code> 里面的 <code>Profiler</code> 工具是一个很好用的工具，通过里面的 <code>memory</code> 工具可以<code>实时监控</code> APP 运行过程中的内存分配。</p><p><img src="https://img.imgdb.cn/item/60742b578322e6675cac02b9.jpg" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/60742b578322e6675cac02b9.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="内存性能分析器"></p><p>dump APP 内存堆栈后，还可以看到各个类占用的内存情况。</p><p><img src="https://img.imgdb.cn/item/60742b928322e6675cac8841.jpg" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/60742b928322e6675cac8841.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="有关每个已分配对象的详细信息显示在右侧的 Instance View 中"></p><p>可以查看每个对象的详细信息。</p><p><code>Android Studio</code> 里面的 <code>Profiler</code> 工具的具体使用教程请参考<a href="https://developer.android.google.cn/studio/profile/memory-profiler?hl=zh-cn">官方教程</a>，这里就不做详细介绍了。</p><h2 id="如何合理使用内存"><a href="#如何合理使用内存" class="headerlink" title="如何合理使用内存"></a>如何合理使用内存</h2><p>利用上面的方法，找到内存消耗大的场景，就需要做优化了，主要做法就是想办法减少特定场景下的内存的使用。个人总结了一下平时可能会做的优化。</p><ul><li>图片相关的优化</li></ul><p>图片是我目前做的应用里面占用内存比较大的一块了，也碰到了一些问题，我主要是通过以下的方法来做优化。</p><ol><li>暂时用不上的图片不加载，比如说，有个网络加载异常的图，不要一开始就初始化，等到真的有异常了需要展示的时候再初始化</li><li>加载图片的时候，尽量加载指定大小的图片，因为有时候会碰到控件的大小小于实际图片尺寸的情况，这个时候，会浪费一些内存。有需要的话，可以让后台返回不同尺寸的图片。</li><li>根据不同的图片格式</li><li>不显示的图片，可以考虑先释放。</li></ol><ul><li>尽可能少地创建对象</li></ul><p>毫无疑问，如果对象少，内存肯定也消耗的少，那平时需要注意哪些呢？</p><ol><li>自定义 view 的时候，不要在 onDraw 方法里面频繁创建对象。因为 onDraw 方法可能会频繁调用，这个时候就会创建大量的对象。从而造成浪费，同时也会导致 gc 触发的频率升高，造成卡顿。</li><li>尽量少创建线程，创建线程其实是比较消耗资源的，创建一个空的线程，大概会占用 1-2 M 内存。同时一般异步任务很快就会执行完，如果频繁创建线程来做异步任务，除了内存使用的多，还可能 GC 造成卡顿。执行异步任务的话，一般建议用线程池来执行，但是需要注意线程池的使用。</li><li>尽量用 StringBuilder 或者 StringBuffer 来拼接字符串。平时发现的问题主要是在打印 logcat 的时候和拼接后台返回的数据的时候会创建大量的 String，所以如果有类似的情况也可以考虑做一些优化。</li></ol><h2 id="内存泄漏是什么"><a href="#内存泄漏是什么" class="headerlink" title="内存泄漏是什么"></a>内存泄漏是什么</h2><p>内存泄漏指的是本应该释放的内存，由于一些原因，被 GC ROOT 对象持有，从而而无法在 GC 的时候释放，这样可能会导致的一个问题就是，重复操作以后，APP 没有足有的内存使用了，这个时候系统会杀死 APP 。所以内存泄漏是需要排查的。</p><h2 id="如何监控和分析内存泄漏问题"><a href="#如何监控和分析内存泄漏问题" class="headerlink" title="如何监控和分析内存泄漏问题"></a>如何监控和分析内存泄漏问题</h2><p>上一个小结总结了上面是内存泄漏，是因为某些 GC ROOT 对象持有了期望释放的对象，导致期望释放的内存无法及时释放。所以如何监控和分析内存泄漏问题就成了如何找到 GC ROOT 的问题。</p><p>一般手动分析的步骤是：重复操作怀疑有内存泄漏的场景，然后触发几次 GC 。等几秒钟后，把 APP 的内存堆栈 dump 下来(可以使用 as 的工具 dump)，然后用 sdk 里面的 cover 工具转换一下，然后用 MAT 工具来分析内存泄漏的对象到 GC ROOT 的引用链。</p><p>手动分析总是很麻烦的，一个好消息是，有一个特别好用的自动监控和分析内存泄漏的工具，这个工具就是 leakcanary ，它可以自动监控并给出内存泄漏的对象到 GC ROOT 的引用链。</p><p>使用很简单，只需要在 APP  的 build.gradle 下面新增</p><pre><code>dependencies &#123;  // debugImplementation because LeakCanary should only run in debug builds.  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.7&#39;&#125;</code></pre><p>leakcanary 比较核心的一个原理就是利用了弱引用的一个特性，这个特性就是：</p><blockquote><p>在创建弱引用的时候，可以指定一个 RefrenceQueue ，当弱引用引用的对象的可达性发生变化的时候，系统会把这个弱引用引用的对象放到之前指定的 RefrenceQueue 中等待处理。</p></blockquote><p>所以 GC 后，引用对象仍然没有出现在 RefrenceQueue 的时候，说明可能发生了内存泄漏，这个时候 leakcanary 就会 dump 应用的 heap ，然后用 shark 库分析 heap ，找出一个到 GC ROOT 的最短引用链并提示。</p><h2 id="常见的内存泄漏的场景"><a href="#常见的内存泄漏的场景" class="headerlink" title="常见的内存泄漏的场景"></a>常见的内存泄漏的场景</h2><p>个人总结了下工作中碰到内存泄漏的一些场景，现记录下来，大家可以参考下。</p><ol><li>静态变量持有 Context 等。</li><li>单例实例持有 Context 等。</li><li>一些回调没有反注册，比如广播的注册和反注册等，有时候一些第三方库也需要注意。</li><li>一些 Listener 没有手动断开连接。</li><li>匿名内部类持有外部类的实例。比如 Handler , Runnable 等常见的用匿名内部类的实现，常常会不小心持有 Context 等外部类实例。</li></ol><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#x34;&#x32;&#x30;&#54;&#52;&#x30;&#x37;&#54;&#x33;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#x34;&#x32;&#x30;&#54;&#52;&#x30;&#x37;&#54;&#x33;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> 内存优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化 - 稳定性优化</title>
      <link href="/android-note/2021/04/07/android_performance/android_performance_app_crash/"/>
      <url>/android-note/2021/04/07/android_performance/android_performance_app_crash/</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/android-note/2021/04/01/android_performance/android_performance_summary/" title="Android 性能优化概要">Android 性能优化概要</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a></li><li><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a></li></ul><h2 id="APP-稳定性的维度"><a href="#APP-稳定性的维度" class="headerlink" title="APP 稳定性的维度"></a>APP 稳定性的维度</h2><p>app 稳定一般指的是 app 能正常运行， app 不能正常运行的情况分为两大类，分别是 <code>Crash</code> 和 <code>ANR</code></p><blockquote><p>Crash：运行过程中发生的错误，是无法避免的。</p></blockquote><blockquote><p>ANR：应用再运行时，由于无法再规定的时间段内响应完，系统做出的一个操作。</p></blockquote><h2 id="如何治理-Crash"><a href="#如何治理-Crash" class="headerlink" title="如何治理 Crash"></a>如何治理 <code>Crash</code></h2><p>应用发生 Crash 是由于应用在运行时，应用产生了一个未处理的异常(就是没有被 try catch 捕获的异常)。这会导致 app 无法正常运行。</p><p>如果需要解决的话，就需要知道这个未处理的异常是在哪里产生的，一般是通过分析未处理的异常的方法调用堆栈来解决问题。</p><p>Android APP 可以分为 2 层，Java 层和 Native 层。所以如何捕获需要分开说。</p><h3 id="Java-层获取未处理的异常的调用堆栈"><a href="#Java-层获取未处理的异常的调用堆栈" class="headerlink" title="Java 层获取未处理的异常的调用堆栈"></a>Java 层获取未处理的异常的调用堆栈</h3><p>这个需要了解 <code>Java</code> 虚拟机是如何把一个未捕获的异常报上来的。</p><p>未捕获的异常，会沿着方法的调用链依次上抛，直到 <code>ThreadGroup</code> 的 <code>uncaughtException</code> 方法</p><pre><code class="java">    public void uncaughtException(Thread t, Throwable e) &#123;        if (parent != null) &#123;            // 递归调用，可以忽略            parent.uncaughtException(t, e);         &#125; else &#123;            // 交给了 Thread.getDefaultUncaughtExceptionHandler() 来处理未捕获的异常            Thread.UncaughtExceptionHandler ueh =                Thread.getDefaultUncaughtExceptionHandler();            if (ueh != null) &#123;                ueh.uncaughtException(t, e);            &#125; else if (!(e instanceof ThreadDeath)) &#123;                System.err.print(&quot;Exception in thread \&quot;&quot;                                 + t.getName() + &quot;\&quot; &quot;);                e.printStackTrace(System.err);            &#125;        &#125;    &#125;</code></pre><p>查阅代码发现，发现 <code>ThreadGroup</code> 最终会给 <code>Thread</code> 的 <code>defaultUncaughtExceptionHandler</code> 处理。</p><pre><code class="java">private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;</code></pre><p> 上面的代码显示：<code>Thread</code> 的 <code>defaultUncaughtExceptionHandler</code> 是 <code>Thread</code> 类的一个静态变量。</p><p>看到这里，如何捕获 <code>Java</code> 层未处理的异常就很清晰了，给 <code>Thread</code> 设置一个<code>新的 defaultUncaughtExceptionHandler</code>，在这个新的<code> defaultUncaughtExceptionHandler</code> 里面收集需要的信息就可以了。</p><p>需要注意的一点是 <code>旧的 defaultUncaughtExceptionHandler</code> 需要保存下来，然后<code>新的 defaultUncaughtExceptionHandler</code> 收集信息后，需要再转给<code>旧的 defaultUncaughtExceptionHandler</code> 继续处理。</p><h3 id="Native-层获取未处理的异常的相关信息"><a href="#Native-层获取未处理的异常的相关信息" class="headerlink" title="Native 层获取未处理的异常的相关信息"></a>Native 层获取未处理的异常的相关信息</h3><p>Java 层如何收集未处理的异常的信息说过了，我们来看看 Native 层发生未处理的异常的话，是如何处理的。 Native 层的处理，需要掌握 linux 的一些知识，由于本人不是特别了解 linux ，这里就直接参考别人的文章了。如果有错误，还请指正。</p><p>本人通过查阅资料发现，Native 层如果发生未处理的异常(注:如果 Native 层捕获了异常，是可以通过 JNI 抛到 Java 层去处理的) ，系统会发出信号给 Native 层，在 Native 层如果要收集未处理的异常信息，就需要注册对应信号的处理函数。当发生异常的时候，Native 层会收到信息，然后通过处理器来收集信息。</p><p>注册信号处理函数如下：</p><pre><code class="c">#include &lt;signal.h&gt; int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</code></pre><ul><li>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</li><li>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</li><li>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</li></ul><p>有了信号处理函数，后面还要做的事情就是收集信息了，由于本人不是很熟悉 Native 的开发，这里就不展开说了了，大家可以参考 <a href="https://www.cnblogs.com/mingfeng002/p/9118253.html">Android 平台 Native 代码的崩溃捕获机制及实现</a>。</p><h2 id="如何治理-ANR"><a href="#如何治理-ANR" class="headerlink" title="如何治理 ANR"></a>如何治理 <code>ANR</code></h2><p><code>ANR</code> 是 <code>Applicatipon No Response</code> 的简称。如果应用卡死或者响应过慢，系统就会杀死应用。为什么要杀死应用？其实也很好理解，如果不杀死应用，大家会以为系统坏了。</p><p>那我们如何监控 <code>ANR</code> 呢？以及我们如何分析 ANR 的问题呢？常见的导致 ANR 的原因有哪些呢？</p><p>首先，<code>ANR</code> 的原理是 <code>AMS</code> 在 <code>UI 操作</code>开始的时候，会根据 <code>UI 操作</code>的类型开启一个延时任务，如果这个任务被触发了，就表示应用卡死或者响应过慢。这个任务会在 <code>UI 操作</code>结束的时候被移除。</p><p>然后，如何分析 <code>ANR</code> 问题呢？</p><p>一般 <code>ANR</code> 发生的时候， <code>logcat</code> 里面会打印 <code>ANR</code> 相关的信息，过滤关键字 <code>ANR</code> 就可以看到，这里不做详细分析，可以参考后面的文章。</p><p>然后一般会在 <code>/data/anr</code> 目录下面生成 <code>traces.txt</code> 文件，里面一般包含了 <code>ANR</code> 发生的时候，系统和所有应用的线程等信息(需要注意的是，不同的 rom 可能都不一样)，通过 <code>logcat</code> 打印的信息和 <code>traces.txt</code> 里面的信息，大部分的 <code>ANR</code> 可以分析出原因，但是呢，也有相当一部分的 ANR 问题无法分析，因为 <code>logcat</code> 和 <code>traces.txt</code> 提供的信息有限，有时候甚至没有特别有用的信息，特别是 <code>Android</code> 的权限收紧， <code>traces.txt</code> 文件在<code>高 Android 版本</code>无法读取，给 <code>ANR</code> 问题的分析增加了不少的困难。不过好在最近发现头条给 <code>ANR</code> 写了一个系列的文章，里面对 ANR 问题的治理方法，个人觉得很好，这里引用一下。</p><ul><li><a href="https://mp.weixin.qq.com/s/ApNSEWxQdM19QoCNijagtg">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li><li><a href="https://mp.weixin.qq.com/s/_Z6GdGRVWq-_JXf5Fs6fsw">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a></li><li><a href="https://mp.weixin.qq.com/s/4-_SnG4dfjMnkrb3rhgUag">今日头条 ANR 优化实践系列分享 - 实例剖析集锦</a></li><li><a href="https://mp.weixin.qq.com/s/OBYWrUBkWwV8o6ChSVaCvw">今日头条 ANR 优化实践系列 - Barrier 导致主线程假死</a></li></ul><p>本人之前写过一个小的<a href="https://github.com/XanderWang/performance">性能监测的工具</a>，其中有监控 <code>UI</code> 线程 <code>Block</code> 的功能，考虑后续加入头条的 <code>ANR</code> 监测机制，等后续完成了，在做一个详细的总结吧。这次的总结就写到这里。</p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#52;&#x32;&#48;&#54;&#x34;&#x30;&#55;&#x36;&#51;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#52;&#x32;&#48;&#54;&#x34;&#x30;&#55;&#x36;&#51;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> 稳定性优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化 - 启动速度优化</title>
      <link href="/android-note/2021/04/06/android_performance/android_performance_app_start/"/>
      <url>/android-note/2021/04/06/android_performance/android_performance_app_start/</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/android-note/2021/04/01/android_performance/android_performance_summary/" title="Android 性能优化概要">Android 性能优化概要</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a></li><li><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a></li></ul><h2 id="启动的类型"><a href="#启动的类型" class="headerlink" title="启动的类型"></a>启动的类型</h2><p>一般分为，冷启动和热启动</p><blockquote><p>冷启动：启动时，后台没有任何该应用的进程，系统需要重新创建一个进程，并结合启动参数启动该应用。</p></blockquote><blockquote><p>热启动：启动时，系统已经有该应用的进程(比如按 home 键临时退出该应用)下启动该应用。</p></blockquote><h2 id="如何获取启动时间"><a href="#如何获取启动时间" class="headerlink" title="如何获取启动时间"></a>如何获取启动时间</h2><ol><li>adb 命令</li></ol><p>adb shell am start -S -W 包名/启动类的全名</p><pre><code>adb shell am start -S -W xxx/xxxActivityStopping: xxxStarting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=xxx/xxxActivity &#125;Status: okActivity: xxx/xxxActivityThisTime: 770TotalTime: 770WaitTime: 848Complete</code></pre><p><strong>ThisTime</strong>: 表示最后一个 Activity 启动时间</p><p><strong>TotalTime</strong>: 表示启动过程中，所有的 Activity 的启动时间</p><p><strong>WaitTime</strong>: 表示应用进程的创建时间 + TotalTime</p><p>一般我们关注 <code>TotalTime</code> 就好了。</p><p>另外，谷歌在 Android4.4（API 19）上也提供了测量方法，在 logcat 中过滤 Displayed 字段也可以看到启动时间</p><blockquote><p>2021-04-06 19:25:52.803 2210-2245 I/ActivityManager: Displayed xxx/xxxActivity: +623ms</p></blockquote><p><code>+623ms</code> 就是Activity 的启动时间。</p><ol start="2"><li>时间戳</li></ol><p>时间戳的方法基于以下的 2 个知识点。</p><ul><li>应用进程刚创建，会调用 Application 的 onCreate 方法。</li><li>首次进入一个 Activity 后会在 onResume() 方法后面调用 onWindowsFocusChange 方法。</li></ul><p>结合这 2 个特性，我们可以在<br>A<br>Application 的 onCreate() 方法和 Activity 的 onWindowsFocusChange 方法里面，通过时间戳来获取应用的冷启动时间。</p><h2 id="如何监控启动过程"><a href="#如何监控启动过程" class="headerlink" title="如何监控启动过程"></a>如何监控启动过程</h2><ol><li>systrace</li></ol><p>systrace 是一个功能很强大的工具，除了可以查看卡顿问题，也可以用来查看应用的启动问题。使用示例如下：</p><blockquote><p>python $ANDROID_HOME/platform-tools/systrace/systrace.py gfx view wm am pm ss dalvik app sched -b 90960 -a 你的包名 -o test.log.html</p></blockquote><p>用 Google  浏览器打开 <code>test.log.html</code> 就可以看到详细的启动信息。</p><ol start="2"><li>Debug 接口</li></ol><pre><code>package android.os;...class Debug &#123;    ...    public static void startMethodTracingSampling(String tracePath, int bufferSize, int intervalUs) &#123;    &#125;    public static void startMethodTracing(String tracePath, int bufferSize) &#123;    &#125;&#125;</code></pre><p>利用 Debug 类的这两个方法，可以生成一个 <code>trace</code> 文件，这个 <code>trace</code> 文件，可以直接在 <code>AS</code> 里面打开，可以看到从 <code>startMethodTracingSampling</code> 到 <code>startMethodTracing</code> 过程中的方法调用等信息，也可以较好的分析启动问题。</p><h2 id="一般有那些优化方法"><a href="#一般有那些优化方法" class="headerlink" title="一般有那些优化方法"></a>一般有那些优化方法</h2><ol><li>耗时操作放到异步进程</li></ol><p>比如文件解压、读写等耗时 IO 操作可以新开一个线程来执行。</p><ol start="2"><li>延时初始化</li></ol><p>即暂时不适用的工具类等延后到使用的时候再去初始化。比如从 xml 里面读取颜色，可以考虑在使用的时候再去读取和解析。</p><ol start="3"><li>线程优化</li></ol><p>线程的创建需要消耗较多的系统系统资源，减少线程的创建。可以考虑共用一个线程池。</p><p>如何检测线程的创建，可以参考我个开源库 <a href="https://github.com/XanderWang/performance">performance</a></p><!-- 4. 设置 windowsbackground 从视觉上优化```<style name="main_activity_style" parent="@android:style/Theme.Light.NoTitleBar.Fullscreen">    <item name="android:windowIsTranslucent">false</item>    <item name="android:windowDisablePreview">false</item>    <item name="android:windowContentOverlay">@null</item>    <item name="android:windowBackground">@drawable/start_activity_layout_bg</item>    <item name="android:background">@null</item></style>``` --><!-- 4. 布局等优化- 合理使用 ViewStub 、merge 和 include 等减少布局的层次- 及时移除不使用的 View 等。- 使用高效的容器，比如 ConstraintLayout ，除了布局效率高，还可以有效减少布局的层次。 --><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#52;&#x32;&#x30;&#54;&#52;&#48;&#55;&#54;&#51;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#52;&#x32;&#x30;&#54;&#52;&#48;&#55;&#54;&#51;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> 启动速度优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化 - APK 瘦身</title>
      <link href="/android-note/2021/04/06/android_performance/android_performance_app_size/"/>
      <url>/android-note/2021/04/06/android_performance/android_performance_app_size/</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><a href="/android-note/2021/04/01/android_performance/android_performance_summary/" title="Android 性能优化概要">Android 性能优化概要</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a></li><li><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a></li></ul><h2 id="如何查看-apk-的组成"><a href="#如何查看-apk-的组成" class="headerlink" title="如何查看 apk 的组成"></a>如何查看 apk 的组成</h2><p>如果要优化 apk 的大小，我们首先需要知道我们编译出来的 apk 都包含哪些东西，然后针对占用大的做裁剪，或者删除不需要的东西，从而达到瘦身的目的。</p><p>查看 apk 的内容占用情况很简单，打开 AS ，把 apk 拖到 AS 里面就可以查看 apk 包含的内容了。</p><p><img src="https://img.imgdb.cn/item/607455ab8322e6675c0bab2c.jpg" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/607455ab8322e6675c0bab2c.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="资源预览"></p><p>可以看到占大头的是 res 代码等，所以瘦身可以从这几个方面来考虑。</p><h2 id="如何减少-res-资源大小"><a href="#如何减少-res-资源大小" class="headerlink" title="如何减少 res 资源大小"></a>如何减少 res 资源大小</h2><ol><li>删除冗余的资源</li></ol><p>一般随着项目的迭代，部分图片等资源不再使用了，但是可能仍然被编译到了 apk 里面，所以可以删除这部分不再使用的资源，可以使用 lint 工具来搜索项目中不再使用的图片等资源。</p><ol start="2"><li>重复资源的优化</li></ol><p>除了有冗余资源，还有些是文件名不一样，但是内容一样的图片，可以通过比较 md5 值来判断是不是一样的资源，然后编辑 resources.arsc 来重定向。</p><ol start="3"><li>图片压缩</li></ol><p>未压缩的图片文件占用空间较大，可以考虑压缩未压缩过的图片来瘦身。常用的工具是  <a href="https://tinypng.com/">tinypng</a> 网站。</p><p>同时也可以借助 <a href="https://github.com/Deemonser/TinyPngPlugin">TinyPngPlugin</a> 等插件或者其他开源工具来帮助压缩图片。</p><ol start="4"><li>资源混淆</li></ol><p>通过将资源路径 <code>res/drawable/wechat</code> 变为 <code>r/d/a</code> 的方式来减少 apk 的大小，当 apk 有较多资源项的时候，效果比较明显，这是一款微信开源的工具，详细地址是：<a href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a></p><ol start="5"><li>指定语言</li></ol><p>如果没有特殊的需求的话，可以只编译中文，因为其他的语言用不上，如果用不上的语言编译了，会在 resource 的表里面占用大量的空间，故</p><pre><code>android &#123;    defaultConfig &#123;        ...        // 仅支持 中文        resConfigs &quot;zh&quot;     &#125;&#125;</code></pre><h2 id="如何减少-so-库资源大小"><a href="#如何减少-so-库资源大小" class="headerlink" title="如何减少 so 库资源大小"></a>如何减少 so 库资源大小</h2><ol><li>自己编译的 so </li></ol><p>release 包的  so 中移除调试符号。可以使用 Android NDK 中提供的 <code>arm-eabi-strip</code> 工具从原生库中移除不必要的调试符号。</p><p>如果是 cmake 来编译的话，可以再编辑脚本添加如下代码</p><pre><code>set(CMAKE_C_FLAGS_RELEASE &quot;$&#123;CMAKE_C_FLAGS_RELEASE&#125; -s&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -s&quot;)</code></pre><ol start="2"><li>别人编译的 so</li></ol><p>联系作者修改，一般很难联系到。</p><ol start="3"><li>动态下发 so</li></ol><p>可以通过服务器下发 so , 下载完后再进入应用，但是体验不好，但是是一个思路。</p><ol start="4"><li>只编译指定平台的 so </li></ol><p>一般我们都是给 arm 平台的机器开发，如果没有特殊情况，我们一般只需要考虑 arm 平台的。具体的方法是 app 下的 build.gradle 添加如下代码</p><pre><code>android &#123;    defaultConfig &#123;        ndk &#123;            abiFilter &quot;armeabi&quot;        &#125;    &#125;&#125;</code></pre><p>各个平台的差别如下：</p><table><thead><tr><th>平台</th><th>说明</th></tr></thead><tbody><tr><td>armeabi-v7a</td><td>arm 第 7 代及以上的处理器，2011 年后的设备基本都是</td></tr><tr><td>arm64-v8a</td><td>arm 第 8 代 64 位处理器设备</td></tr><tr><td>armeabi</td><td>arm 第 5、6 代处理器，早期的机器都是这个平台</td></tr><tr><td>x86</td><td>x86 32 位平台，平板和模拟器用的多</td></tr><tr><td>x86_64</td><td>x86 64 位平台</td></tr></tbody></table><h2 id="如何减少代码资源大小"><a href="#如何减少代码资源大小" class="headerlink" title="如何减少代码资源大小"></a>如何减少代码资源大小</h2><ol><li>一个功能尽量用一个库</li></ol><p>比如加载图片库，不要 glide 和 fresco 混用，因为功能是类似的，只是使用的方法不一样，用了多个库来做类似的事情，代码肯定就变多了。</p><ol start="2"><li>混淆</li></ol><p>混淆的话，减少了生成的 class 大小，这样积少成多，也可以从一定层度减少 apk 的大小。</p><ol start="3"><li>R 文件内联</li></ol><p>通过把 R 文件里面的资源内联到代码中，从而减少 R 文件的大小。</p><p>可以使用 <a href="https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/README-zh.md">shrink-r-plugin</a> 工具来做 R 文件的内联</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html">Android App包瘦身优化实践</a></p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#52;&#x32;&#x30;&#54;&#52;&#x30;&#x37;&#x36;&#x33;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;">&#52;&#x32;&#x30;&#54;&#52;&#x30;&#x37;&#x36;&#x33;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
            <tag> APK 瘦身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Week Blog 2021.0329-0402</title>
      <link href="/android-note/2021/04/02/android_week_blog/week_2021_0329_0402/"/>
      <url>/android-note/2021/04/02/android_week_blog/week_2021_0329_0402/</url>
      
        <content type="html"><![CDATA[<h2 id="优秀文章"><a href="#优秀文章" class="headerlink" title="优秀文章"></a>优秀文章</h2><ul><li><a href="https://juejin.cn/post/6944960866404007944">深入Android系统（十二）Android图形显示系统-1-显示原理与Surface</a></li></ul><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周报 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化总结 - 概要</title>
      <link href="/android-note/2021/04/01/android_performance/android_performance_summary/"/>
      <url>/android-note/2021/04/01/android_performance/android_performance_summary/</url>
      
        <content type="html"><![CDATA[<p>性能的优化是一个老生常谈的点，也是一个比较重要的点。做过一点性能优化的工作，现在对工作中的优化点做一个总结。如有错误，还请指正。</p><h1 id="有哪些方面需要优化"><a href="#有哪些方面需要优化" class="headerlink" title="有哪些方面需要优化"></a>有哪些方面需要优化</h1><p>在平时的优化过程中我们需要从哪几个点来优化呢？其实我们平时自己一定也用过软件，在使用软件的过程中有没有什么想吐槽的呢？</p><p>“这个 app 怎么还没下载完！”、“太卡了吧！”、”图片怎么还没加载出来！”、”怎么刚进去就卡了！”、“这么点了一下就退出了！”等等，是不是有这样的想法？这些想法其实包含了我们今天要说的内容，就是从哪些方面来优化我们的 APP ，我总结了以下几点。</p><ul><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a></li><li><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a></li><li><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a></li><li><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a></li></ul><!-- ## 系列文章- [Android 性能优化总结 - 概要](https://blog.csdn.net/wxy318/article/details/115675841)- [Android 性能优化总结 - APK 瘦身优化](https://blog.csdn.net/wxy318/article/details/115675595)- [Android 性能优化总结 - 启动速度优化](https://blog.csdn.net/wxy318/article/details/115675620)- [Android 性能优化总结 - 稳定性优化](https://blog.csdn.net/wxy318/article/details/115675643)- [Android 性能优化总结 - 内存的优化](https://blog.csdn.net/wxy318/article/details/115675656)- [Android 性能优化总结 - 操作流畅度优化](https://blog.csdn.net/wxy318/article/details/115675663)--><!-- ## 系列文章- [Android 性能优化总结 - 概要](https://my.oschina.net/u/698631/blog/5017875)- [Android 性能优化总结 - APK 瘦身优化](https://blog.csdn.net/wxy318/article/details/115675595)- [Android 性能优化总结 - 启动速度优化](https://blog.csdn.net/wxy318/article/details/115675620)- [Android 性能优化总结 - 稳定性优化](https://blog.csdn.net/wxy318/article/details/115675643)- [Android 性能优化总结 - 内存的优化](https://blog.csdn.net/wxy318/article/details/115675656)- [Android 性能优化总结 - 操作流畅度优化](https://blog.csdn.net/wxy318/article/details/115675663) --><p>当然，需要优化的不仅仅是这几个方面，我做的比较多的优化是这几个方面，暂时就这几个方面来谈谈优化吧。</p><h1 id="APK-瘦身"><a href="#APK-瘦身" class="headerlink" title="APK 瘦身"></a>APK 瘦身</h1><p>APK 包如果小的话，下载和安装的时间都会变快，而且较少的投入可以看到较明显的效果，APK 瘦身很值得优化，具体的优化方法可以参考下面的连接。</p><a href="/android-note/2021/04/06/android_performance/android_performance_app_size/" title="APK 瘦身优化">APK 瘦身优化</a><h1 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h1><p>启动速度是每个应用都会碰到和需要优化的，这里总结了一下本人工作中的启动优化，详细的内存请参考下面的链接。</p><a href="/android-note/2021/04/06/android_performance/android_performance_app_start/" title="启动速度优化">启动速度优化</a><h1 id="稳定性优化"><a href="#稳定性优化" class="headerlink" title="稳定性优化"></a>稳定性优化</h1><p>稳定性优化，是个重中之重的优化了，毕竟没有谁喜欢在使用 APP 的过程中“闪退”。我是如何做稳定性优化的？可以参考下面的链接。</p><a href="/android-note/2021/04/07/android_performance/android_performance_app_crash/" title="稳定性优化">稳定性优化</a><h1 id="内存的优化"><a href="#内存的优化" class="headerlink" title="内存的优化"></a>内存的优化</h1><p>内存的优化，是一个持久的优化，因为我发现，经常是这次修好了，下次另外一个地方又有问题了，我对内存的优化工作可以参考下面的链接。</p><a href="/android-note/2021/04/10/android_performance/android_performance_app_memory/" title="内存的优化">内存的优化</a><h1 id="操作流畅度优化"><a href="#操作流畅度优化" class="headerlink" title="操作流畅度优化"></a>操作流畅度优化</h1><p>流程度的优化说起来，也是很重要的。毕竟动不动就卡顿的体验属实不好，按照惯例，操作流畅度优化可以参考下面的链接。</p><a href="/android-note/2021/04/10/android_performance/android_performance_app_caton/" title="操作流畅度优化">操作流畅度优化</a><h1 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h1><ul><li><p>Github: <a href="https://github.com/XanderWang">https://github.com/XanderWang</a></p></li><li><p>Mail: <a href="mailto:&#52;&#50;&#x30;&#54;&#52;&#x30;&#x37;&#54;&#51;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;">&#52;&#50;&#x30;&#54;&#52;&#x30;&#x37;&#54;&#51;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;</a></p></li><li><p>Blog: <a href="https://xander_wang.gitee.io/android-note/">https://xander_wang.gitee.io/android-note/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 脚本 -a 到 -n 的意思</title>
      <link href="/android-note/2021/02/28/linux/shell_a_to_n/"/>
      <url>/android-note/2021/02/28/linux/shell_a_to_n/</url>
      
        <content type="html"><![CDATA[<ul><li>[-a file]  </li></ul><p>如果 file 存在则为真</p><ul><li>[-b file]  </li></ul><p>如果 file 存在且是一个块特殊文件则为真</p><ul><li>[-c file]  </li></ul><p>如果 file 存在且是一个字特殊文件则为真</p><ul><li>[-d file]  </li></ul><p>如果file文件存在且是一个目录则为真<br>-d 前的 ! 是逻辑非<br>例如：<br>if [ ! -d $lcd_path/$par_date ] 表示后面的那个目录不存在，则执行后面的 then 操作</p><ul><li>[-e file] </li></ul><p>如果 file 文件存在则为真</p><ul><li>[-f file] </li></ul><p>如果 file 存在且是一个普通文件则为真</p><ul><li>[-g file] </li></ul><p>如果 file 存在且已经设置了 SGID 则为真（SUID 是 Set User ID, SGID 是 Set Group ID的意思）</p><ul><li>[-h file] </li></ul><p>如果 file 存在且是一个符号连接则为真</p><ul><li>[-k file] </li></ul><p>如果 file 存在且已经设置粘制位则为真</p><p>当一个目录被设置为”粘制位”(用chmod a+t),则该目录下的文件只能由</p><ol><li>超级管理员删除</li><li>该目录的所有者删除</li><li>该文件的所有者删除</li></ol><p>也就是说,即便该目录是任何人都可以写,但也只有文件的属主才可以删除文件。</p><p>具体例子如下：</p><p>#ls -dl /tmp</p><p>drwxrwxrwt 4 root root ………</p><p>注意other位置的t，这便是粘连位。</p><ul><li>[-p file] </li></ul><p>如果 file 存在且是一个名字管道（F如果O）则为真<br>管道是 linux 里面进程间通信的一种方式，其他的还有像信号（signal）、信号量、消息队列、共享内存、套接字（socket）等。</p><ul><li>[-r file] </li></ul><p>如果 file 存在且是可读的则为真</p><ul><li>[-s file] </li></ul><p>如果 file 存在且大小不为 0 则为真</p><ul><li>[-t FD] </li></ul><p>如果文件描述符 FD 打开且指向一个终端则为真</p><ul><li>[-u file] </li></ul><p>如果 file 存在且设置了SUID（set userID）则为真</p><ul><li>[-w file] </li></ul><p>如果 file 存在且是可写的则为真</p><ul><li>[-x file] </li></ul><p>如果 file 存在且是可执行的则为真</p><ul><li>[-O file] </li></ul><p>如果 file 存在且属有效用户ID则为真</p><ul><li>[-G file] </li></ul><p>如果 file 存在且属有效用户组则为真</p><ul><li>[-L file] </li></ul><p>如果 file 存在且是一个符号连接则为真</p><ul><li>[-N file] </li></ul><p>如果 file 存在 and has been mod 如果 ied since it was last read 则为真</p><ul><li>[-S file] </li></ul><p>如果 file 存在且是一个套接字则为真</p><ul><li>[file1 –nt file2] </li></ul><p>如果 file1 has been changed more recently than file2 或者 file1 exists and file2 does not 则为真</p><ul><li>[file1 –ot file2] </li></ul><p>如果 file1 比 file2 要老，或者 file2 存在且 file1 不存在则为真</p><ul><li>[file1 –ef file2] </li></ul><p>如果 file1 和 file2 指向相同的设备和节点号则为真</p><ul><li>[-o optionname] </li></ul><p>如果 shell 选项 “optionname” 开启则为真</p><ul><li>[-z string] </li></ul><p>“string” 的长度为零则为真</p><ul><li>[-n string] or [string] </li></ul><p>“string” 的长度为非零 non-zero 则为真</p><ul><li>[sting1==string2] </li></ul><p>如果 2 个字符串相同。</p><ol><li>“=” may be used instead of </li><li>“==” for strict posix compliance<br>则为真</li></ol><ul><li>[string1!=string2] </li></ul><p>如果字符串不相等则为真</p><ul><li>[string1&lt;string2] </li></ul><p>如果 “string1” sorts before “string2”，lexicographically in the current locale 则为真</p><ul><li>[arg1 OP arg2] </li></ul><p>“OP”is one of –eq,-ne,-lt,-le,-gt or –ge.These arithmetic binary oprators return true if “arg1”is equal to,not equal to,less than,less than or equal to,greater than,or greater than or equal to“agr2”,respectively.“arg1”and “agr2”are integers.</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发总结笔记(六) - 网络编程总结</title>
      <link href="/android-note/2021/02/26/android_note/android_note_06/"/>
      <url>/android-note/2021/02/26/android_note/android_note_06/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程总结"><a href="#网络编程总结" class="headerlink" title="网络编程总结"></a>网络编程总结</h1><h2 id="网络协议总览"><a href="#网络协议总览" class="headerlink" title="网络协议总览"></a>网络协议总览</h2><h3 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h3><p><img src="https://img-blog.csdnimg.cn/20190311164958423.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20190311164958423.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="网络协议分层图"></p><h3 id="网络协议框架"><a href="#网络协议框架" class="headerlink" title="网络协议框架"></a>网络协议框架</h3><p><img src="https://pic2.zhimg.com/80/v2-0ca19e8fa75661a2de8fbbc93f060c05_720w.jpg" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-0ca19e8fa75661a2de8fbbc93f060c05_720w.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="网络协议框架图"></p><h3 id="各层协议之间的区别合联系"><a href="#各层协议之间的区别合联系" class="headerlink" title="各层协议之间的区别合联系"></a>各层协议之间的区别合联系</h3><pre><code>应用层: Http WebSocket FTP 等传输层: TCP UDP网络层: IP链路层: -</code></pre><ul><li>TCP 和 UDP</li></ul><blockquote><p>TCP 是面向连接的一种传输控制协议。TCP 链接连通后，客户端和服务器可以互相发送和接收消息。在客户端或者服务端没有主动断开链接的情况下，链接一直存在，所以一般 TCP 也成为长链接。TCP 的特点是，连接有耗时(三次握手)，数据传输无限制，准确可靠。</p></blockquote><blockquote><p>UDP 是无连接的用户数据报协议。无连接就是传输数据前不用建立连接，直接向指定位置传输数据。特点是速度快，但不稳定，可广播，数据大小有限制。</p></blockquote><p>两者比较的话， TCP 可以类比打电话， UDP 可以类比发短信。</p><ul><li>HTTP</li></ul><blockquote><p>HTTP 是基于 TCP 协议的，请求时，建立 TCP 连接，请求结束后断开连接。HTTP v1.1 版本新增了 keep-alive ，可以复用之前的 TCP 连接，减少资源消耗。这个也是网络优化的一个点。</p></blockquote><ul><li>WebSocket</li></ul><blockquote><p>WebSocket 也是一种协议，属于应用层。WebSocket 协议分为 2 部分，一部分为”连接”，一部分为”数据传输”。</p></blockquote><ul><li>Socket 连接和 TCP 连接</li></ul><blockquote><p>Socket 是传输层的门面，TCP 和 UDP 是一个协议，应用层和传输层之间的交互是通过 Socket 来实现的。</p></blockquote><ul><li>HTTP 和 WebSocket 的区别</li></ul><blockquote><p>都是应用层的协议，而且都是基于 TCP 协议的，不同的是 HTTP 无状态的一次连接后就会关闭， WebSocket 是全双工的，连接后可以互相发送和接收消息。 </p></blockquote><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="HTTP-协议是什么"><a href="#HTTP-协议是什么" class="headerlink" title="HTTP 协议是什么"></a>HTTP 协议是什么</h3><p>HTTP 协议的中文翻译是超文本传输协议，从字面的意思来看，HTTP 协议是用来解决互联网上的机器之间如何传输超文本内容问题的协议。</p><h3 id="HTTP-协议是如何工作的"><a href="#HTTP-协议是如何工作的" class="headerlink" title="HTTP 协议是如何工作的"></a>HTTP 协议是如何工作的</h3><p>HTTP 协议是用来解决互联网上 2 台机器之间传输超文本内容的问题的。我们先看一个基础的问题， 2 台机器如何传输数据。</p><p>这是一个很复杂的问题，涉及到软硬件之前的协作。直接通讯肯定和硬件相关，通讯的内容是什么和软件相关。为了更好的发展，或者说减少网络开发的门槛，整个网络相关的开发(软硬件)，理论上分成了 7 层，实际实现了 4 层。</p><p><img src="https://img-blog.csdnimg.cn/20190311164958423.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20190311164958423.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="网络分层图"></p><p>分层设计的好处就是各层相互独立，同时减少耦合，提高了开发效率，易扩展。</p><p>HTTP 协议是建立在 TCP/IP 的基础上的，属于应用层。</p><p>数据在网络上的流向大概下面</p><blockquote><p>发送方机器应用层封装原始数据后传给传输层。 -&gt; 传输层接收应用层数据后封装数据，然后把数据传递给网络层。 -&gt; 网络层接收数据后封装数据，然后把数据传递给链路层。 -&gt; 链路层把数据交给网络，最终数据传递到了接收方机器 -&gt; 接收方机器链路层收到发送方链路层的数据 -&gt; 接收方网络层接收到链路层数据，解开数据后传给传输层 -&gt; 接收方传输层接收到数据后，解开数据，然后把数据传给应用层 -&gt; 接收方应用层接收到数据后，解析数据然后展示。</p></blockquote><h3 id="TCP-IP-的三次握手和四次挥手"><a href="#TCP-IP-的三次握手和四次挥手" class="headerlink" title="TCP/IP 的三次握手和四次挥手"></a>TCP/IP 的三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>上一小节简单描述了数据在整个网络中的大概流向。有一些相对来说关键且重要的问题。</p><ol><li>如何保证接收方是我们的期望接收方？</li><li>如何能保证网络相对稳定可靠，即 C 和 S 都觉得对方和自己都是可以接收和发送消息的？</li></ol><p>三次握手就是用来解决这些关键问题的，主要是解决问题 2 的，因为问题1 不管是几次握手都需要解决的。</p><p>先说下三次握手是如何工作的，然后再说下为什么是三次握手。</p><ol><li>第一次握手: C 端 发送 SYN=1 信号，同时 seq=x 来请求 S 端</li><li>第二次握手: S 端 发送 SYN=1 ACK=1 信号，同时 seq=y ack=x+1 给 C 端，表示对 C 的 SYN 信号应答，同时发送一个 SYN </li><li>第三次握手: C 端发送一个 ACK=1 信号，同时 ack=y+1 ，服务器接收到后就可以开始传输数了，</li></ol><p>因为经过三次握手， C 端确认了自己是可以发送和接收的，S 端也是可以发送和接收的(1-2握手)。<br>S 端也确认了自己是可以发送和接收的，同时 C 端也是可以接收和发送的(2-3握手)。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>tcp/ip 是全双工的，就是说 C 和 S 都是有发送和接收的。断开的时候需要发送和接收都断开。所以需要四次挥手来做到。</p><ol><li>第一次挥手 C 发送 FIN=1 信号， seq=u ，接着 <strong>C 关闭发送数据</strong>，就是说后续不能发送数据流，表示数据发送完。</li><li>第二次挥手 S 发送 ACK=1 信号，ack=u+1,seq=v 表示接收到了 C 的 FIN 信号。</li><li>第三次挥手 S 发送 FIN=1,ACK=1 信号，同时 seq=w,ack=u+1 然后 <strong>S 关闭接收数据</strong>，即后续 S 不在接收数据，数据发送完了。</li><li>第四次挥手 C 端接收到第三次挥手的请求后，发送 ACK=1 信号，表示确认接受完数据， S 端可以关闭接收了，2 timel 后 <strong>C 端关闭接收</strong>。同时 S 端接收到第四次挥手请求后<strong>，S 端关闭接收</strong></li></ol><p>至此，挥手完毕。</p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104903925">重学TCP/IP协议和三次握手四次挥手</a></p><h3 id="如何理解-HTTP-协议是无状态的，无连接的"><a href="#如何理解-HTTP-协议是无状态的，无连接的" class="headerlink" title="如何理解 HTTP 协议是无状态的，无连接的"></a>如何理解 HTTP 协议是无状态的，无连接的</h3><p>无连接，或者叫无持续连接合适些。最早的协议，一次处理一个连接，连接处理完后，就断开，后续加了 keep-alive 来解决这个问题。</p><p>无状态，是指两次连接之间没有关系，不会记录两次连接之间的关系。实际交互也许有关系，但是作为两次连接，在通讯的时候，是没有关系的，就是不会直接有影响两次连接。这是协议的内容，但是实际搞了个 cookies </p><p><a href="https://www.cnblogs.com/bellkosmos/p/5237146.html">http协议无状态中的 “状态” 到底指的是什么？！</a></p><h3 id="HTTP-各个版本比较"><a href="#HTTP-各个版本比较" class="headerlink" title="HTTP 各个版本比较"></a>HTTP 各个版本比较</h3><ul><li>http 0.9 </li><li>http 1.0 新增了 POST GET PUT 等方式，新增了请求头和响应头概念，扩充了传输的内容格式。图片等都可以传输了。</li><li>http 1.1 目前引用最广泛的协议，做了优化，支持 keep-alive，管道化、断点续传。</li><li>http 2.0 主要是改进传输性能，实现低延迟和高吞吐。采用二进制传输数据。</li><li>http 3.0 将弃用TCP协议，改为使用基于UDP协议的QUIC协议实现。</li></ul><h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul><li><p>语义上的区别， GET 用户请求数据，一般请求到的内容是固定的， POST 一般是向服务器提交数据。</p></li><li><p>GET 请求参数在 url 中， post 请求参数在 request body 里面。</p></li><li><p>GET 是安全、幂等和可缓存的， POST 是不安全，不幂等和不可缓存的。(安全是说，资源是只读的，幂等是指请求一次或者多次，返回的结果都是一样的。可缓存的)</p></li></ul><p>参考资料:</p><p><a href="https://www.zhihu.com/question/28586791">GET 和 POST 到底有什么区别？</a></p><p><a href="https://zhuanlan.zhihu.com/p/112537312">TCP、UDP、HTTP、SOCKET、WebSocket之间的区别</a></p><p><a href="https://www.jianshu.com/p/42260a2575f8">1小时教你理解HTTP，TCP，UDP，Socket，WebSocket</a></p><h2 id="HTTPS-协议原理"><a href="#HTTPS-协议原理" class="headerlink" title="HTTPS 协议原理"></a>HTTPS 协议原理</h2><p>HTTPS 是在 HTTP 中加入了一层 SSL/TLS 加密层，用来保护中间数据的安全。</p><p>需要注意的而是 HTTP 和 HTTPS 都是基于 TCP/IP 协议的，就是说 HTTPS 先进行三次握手建立链接后，才做证书认证等</p><p>在介绍 HTTPS 之前，我们先简单介绍下密码学的一些基础知识。</p><blockquote><p>明文: 未被加密的原始数据 </p></blockquote><blockquote><p>密文: 加密后的数据，无法直接查看，需要通过解密后才可以查看</p></blockquote><blockquote><p>密钥: 一种参数，用于明文转为密文，或者密文转为明文时候的参数，分为对称密钥和非对称密钥。</p></blockquote><blockquote><p>对称加密: 也叫私钥加密，即数据的发送者和接收者用的是用一个密钥来加密和解密数据。加密过程中的密钥称为私钥，即不能公开，私人所有。公开后或者泄露后，第三方很容易解密密文。</p></blockquote><blockquote><p>非对称加密:也叫做公钥加密。密钥是一对，分为公钥和密钥，加密的时候可以用公钥或者密钥中的一个加密，解密的时候需要用另外一个密钥解密。</p></blockquote><p>HTTPS 实际上是 HTTP 协议 + SSL/TLS 协议，就是说内容通过 SSL/TLS 协议加密后，在通过 HTTP 协议传输。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNjA4MjIwMzM3Njky?x-oss-process=image/format,png" class="lazyload placeholder" data-srcset="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNjA4MjIwMzM3Njky?x-oss-process=image/format,png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="HTTPS 原理图"></p><p>HTTPS 涉及到了对称加密和非对称加密，可以分为 8 个小步骤</p><ol><li>客户端向服务器 443 端口发起 HTTPS 请求。</li><li>服务器接收到请求后，找到保存的公钥和密钥。</li><li>服务器发送公钥(也就是证书)给客户端。</li><li>客户端接收到公钥后，验证公钥是否有效，如果无效，提示异常；如果有效，那么生成一个随机的密钥。</li><li>客户端用公钥对这个生成的密钥加密后发送给服务器。</li><li>服务器接收到加密后的随机密钥后，服务器用密钥加密后的带随机密钥。</li><li>服务器用随机密钥加密数据后发送给服务器。</li><li>客户端接收到数据后用随机密钥解密，就可以得到数据。</li></ol><p>这里面涉及到了非对称加密和对称加密。</p><ul><li>非对称加密用于校验网站公钥，也就是证书。同时用来加密客户端生成的随机密钥</li><li>随机密钥用于对称加密，用于加密数据。</li></ul><p>第 4 步的验证公钥是否有效，需要说到公钥(证书)的来由，是由网站去 CA 组织申请的，申请通过后，CA 会用自己的私钥对网站信息，授权的期限等信息加密后生成的一个数字证书。简单说就是网站的公钥(证书)是 CA 组织私钥加密后的产物，然后终端设备都会内置 CA 组织的所有公钥。在终端设备拿到网站证书后，会用内置的 CA 公钥对网站证书解密，如果成功解密，就可以根据解密后的信息来判断当前证书是否有效，如果不能解密成功，说明网站公钥(证书)无效。 </p><p><a href="https://www.jianshu.com/p/14cd2c9d2cd2">Https原理及流程</a></p><p><a href="https://blog.csdn.net/iispring/article/details/51615631">HTTPS理论基础及其在Android中的最佳实践</a></p><h3 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h3><p>HTTPS 加密的</p><h2 id="网络开源库框架有哪些"><a href="#网络开源库框架有哪些" class="headerlink" title="网络开源库框架有哪些"></a>网络开源库框架有哪些</h2><ul><li>httpclient 废弃不用了</li><li>volley 基本不用了</li><li>okhttp 在用，主流网络请求框架</li></ul><h3 id="okhttp-源码解析"><a href="#okhttp-源码解析" class="headerlink" title="okhttp 源码解析"></a>okhttp 源码解析</h3><p>1 创建一个 OkHttpClient</p><p>2 创建一个 Request</p><p>3 调用 OkHttpClient 的 newCall 方法后生成一个 RealCall</p><p>4 调用 RealCall 的 execute 同步开始请求或者异步加入队列</p><p>5 同步调用的时候会调用 RealInterceptorChain 的 proceed 方法，这个方法做的事情主要是通过找到 interceptor ，然后把任务交给 interceptor 的 intercept 方法继续执行。</p><p><a href="https://www.jianshu.com/p/82f74db14a18">OKHttp源码解析(一)–初阶</a></p><h2 id="如何优化网络"><a href="#如何优化网络" class="headerlink" title="如何优化网络"></a>如何优化网络</h2><ul><li>开启 Gzip 压缩，开启后可以减少数据传输的大小，减少数据传输时间。</li><li>考虑用 Protocol Buffer 代替 JSON 或者 XML， XML 肯定是需要替换的。</li><li>OKHttp 接入 HTTPDNS，在 <code>OkHttp.build()</code> 时，通过 <code>dns()</code> 方法配置。HTTPDNS 的好处就是绕过运营商的 LocalDNS 解析，提高解析效率和有效防止域名劫持。</li><li>okhttpClient 尽量只创建一个实例。这样请求都在一个线程池里面。</li></ul><p>参考资料:</p><p><a href="https://github.com/soulrelay/InterviewMemoirs/issues/7">OkHttp3线程池相关之Dispatcher中的ExecutorService</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> 三次握手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发总结笔记(五) - Java 线程总结</title>
      <link href="/android-note/2021/02/26/android_note/android_note_05/"/>
      <url>/android-note/2021/02/26/android_note/android_note_05/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程总结"><a href="#Java-线程总结" class="headerlink" title="Java 线程总结"></a>Java 线程总结</h1><h2 id="Java-线程安全"><a href="#Java-线程安全" class="headerlink" title="Java 线程安全"></a>Java 线程安全</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>在上一节的 Java 内存模型里面说到，程序在运行的时候，线程并不是直接从主存里面，而是先从主内存拷贝一份到工作内存(线程私有的)，然后执行代码，最后把计算结果从工作内存写回到主内存。</p><p>有个小问题，为是么需要 JMM ？</p><p>cpu 在存取数据或者存取指令的时候，如果都是在一片连续的区域，效率会高，所以栈里面会有一个变量的副本，这样会把需要参与计算的变量放到一片连续的区域，会提高执行效率，但是这样就会有一个数一致性问题，也就是线程安全问题。说到底就是数据同步问题。</p><p>当有多个线程同时访问同一个变量的时候，因为线程在运算的时候，可能并不是拿的“最新”的值来参与计算的，或者说，参与计算的值不是“最新的”，因为其他线程更新了这个变量，但是线程不知道，还是用的“旧的值”。最终，执行完代码后，写回到主存的值是不符合预期的值。这种情况就是线程不安全，所以，对应的，线程安全就是多个线程同时访问同一个变量的时候，最终的结果和预期结果一致，就表明是线程安全的。</p><p>线程要保证安全，需要满足三个条件</p><ul><li>原子性(Synchronized / Lock)</li></ul><p>原子性的意思是，某个操作要么执行完，要么不做。比如读取值，执行时，开始读数据了，需要保证不能被打断。要么不读值。</p><ul><li>可见性(Volatile / Synchronized / Lock)</li></ul><p>可见性的意思是对值得读写可以立刻捕获，就是说某个线程可以“观察”到其他线程对值得修改，同时，这个线程对值的修改，其他线程也可以“观察”到。</p><ul><li>有序性(Volatile / Synchronized / Lock)</li></ul><p>说到有序性需要说到指令重排，指令重排是为了提高 CPU 的指令执行效率，执行代码的时候，会把一些源码上的不影响方法执行结果的代码打乱执行，以提高 CPU 执行效率。有序性的意思就是说最终代码编译的指令是按照代码的书写顺序执行的。</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>上面说到了，线程安全在于没有“及时”读取到最新的值。要想“及时”读取到最新的值，我们需要用到 volatile 关键字，我们先看看值是如何读取的。</p><h4 id="Java-变量的读写"><a href="#Java-变量的读写" class="headerlink" title="Java 变量的读写"></a>Java 变量的读写</h4><p>Java 变量读的读写是以下的指令来完成的，通过以下的指令，把变量的值从主内存读取到工作内存，工作内存变化后，写入主内存。</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>lock</td><td>作用于主内存，把变量标识为线程独占状态。</td></tr><tr><td>unlock</td><td>作用于主内存，解除独占状态。</td></tr><tr><td>read</td><td>作用主内存，把一个变量的值从主内存传输到线程的工作内存。</td></tr><tr><td>load</td><td>作用于工作内存，把 read 操作传过来的变量值放入工作内存的变量副本中。</td></tr><tr><td>use</td><td>作用工作内存，把工作内存当中的一个变量值传给执行引擎。</td></tr><tr><td>assign</td><td>作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</td></tr><tr><td>store</td><td>作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</td></tr><tr><td>write</td><td>作用于主内存的变量，把 store 操作传来的变量的值放入主内存的变量中。</td></tr></tbody></table><h4 id="volatile-如何保持内存可见性"><a href="#volatile-如何保持内存可见性" class="headerlink" title="volatile 如何保持内存可见性"></a>volatile 如何保持内存可见性</h4><ul><li>read、load、use 动作必须连续出现。</li><li>assign、store、write 动作必须连续出现。</li></ul><p>所以，使用 volatile 变量能够保证:</p><ul><li>每次<code>读取前</code>必须先从主内存刷新最新的值。</li><li>每次<code>写入后</code>必须立即同步回主内存当中。</li></ul><p>有了这 2 条规则，线程就可以及时“观察”到变量值得变化了。</p><h4 id="volatile-如何防止指令重排序"><a href="#volatile-如何防止指令重排序" class="headerlink" title="volatile 如何防止指令重排序"></a>volatile 如何防止指令重排序</h4><p>通过内存屏障来实现的。</p><table><thead><tr><th>屏障</th><th>举例</th><th>含义</th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>Load2 以及之后的读操作要在 Load1 完成之后</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store</td><td>Store2 以及之后的写操作要在 Load1 完成之后</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>Store2 以及之后的写操作要在 Store1 完成之后</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>Load2  以及之后的读操作需要在 Store1 完成之后</td></tr></tbody></table><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。然而，对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。</p><p>下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p><a href="https://monkeysayhi.github.io/2016/11/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86/">volatile关键字的作用、原理</a></p><p><a href="https://www.cnblogs.com/zhengbin/p/6407137.html">Java内存模型</a></p><p><a href="https://www.cnblogs.com/chenyangyao/p/5269622.html">JVM内存模型、指令重排、内存屏障概念解析</a></p><p>解决这个问题(线程不安全)的办法有以下几种方式</p><ol><li>synchronized</li><li>Lock + volatile</li></ol><p>说到底，线程安全的主要的思想就是利用某种方式，保证同时只有一个线程在使用这个变量或者说是方法块，其他的线程“阻塞”，等待正在执行的线程执行完。线程油冰雪执行变成串行执行。</p><h3 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized 通过字节码指令 enterMoniter 和 exitMoniter 实现同时只有一个线程可以执行某段代码块，等这段代码块执行完以后，其他的线程才可以执行。</p><p>这里面需要了解 synchronized 的作用对象，作用对象是一个 Object 。</p><p>大概的原理就是:每个对象都有一个对象头，这个对象头里面存储了相应的锁的信息(无锁、偏向锁、轻量锁和重量锁)。当代码执行到 synchronized 代码的时候，会看这个锁作用的对象的对象头，是有锁还是无锁，无锁就加锁后继续执行。有锁后就阻塞，等待其他线程执行完。</p><p>但是一开始 synchronized 是一个比较重的操作，后续做了优化，这些优化分别是自旋锁、轻量锁、偏向锁。</p><p>自旋就是不会立即 block 线程，而是做一段小的自循环，如果还是无法获取锁，再 block 线程。</p><p>轻量锁是指，虽然对于同一段代码，有多个线程竞争，但是竞争发生在不同的时间段。轻量锁的做法是第一次对锁对象加锁的时候，锁对象的对象头记录指向线程中的锁记录。再次执行代码，加锁锁对象的时候，如果锁对象的对象头指向的锁记录是这个线程，就直接执行，跳过加锁过程。</p><p>偏向锁就是，锁对象被加锁的时候，锁对象的对象头会保存持有锁的线程 id , 当同步代码执行完后，再次对锁对象加锁的时候，如果锁对象的对象头是偏向锁，并且 thread id 是当前线程，那么就不做加锁过程，直接执行。</p><p>轻量级锁和偏向锁如果存在竞争，最终还是会膨胀为重量锁的。</p><h4 id="锁膨胀过程"><a href="#锁膨胀过程" class="headerlink" title="锁膨胀过程"></a>锁膨胀过程</h4><p>偏向锁(01)：做一次 cas 操作，如果成功，说明获取偏向锁成功，对象头记录获取锁的 ThreadId ，如果失败，说明有竞争，这个时候需要膨胀为轻量级锁。</p><p>轻量级锁(00)：某个线程获取锁的时候，如果对象头是偏向锁，就看 ThreadId 对应的线程是否还活着，如果活着，就看是否退出同步块，如果不存活或者已经退出同步块，就尝试 cas 操作获取偏向锁，如果 cas 失败，说明有竞争，这个时候需要由偏向锁膨胀为轻量级锁，具体的过程就是 JVM 会把当前获取锁的线程挂起，然后再线程的当前栈帧里面创建一个锁记录，然后把对象头用 CAS 拷贝进去，同时创建一个 Owner 指针指向锁对象的对象头，然后锁对象的对象头指向这个锁记录，然后之前获取锁的线程继续执行，没有获取到锁的线程先自旋一段时间，如果自旋结束后成功获取到轻量级锁，就继续执行，如果自旋后还是获取不到轻量级锁，说明由更严重(多个线程)的竞争，需要膨胀为重量级锁。</p><p>重量级锁(10)：线程</p><p>参考资料：</p><p><a href="https://juejin.im/post/5ca766dcf265da30d02fb35c">https://juejin.im/post/5ca766dcf265da30d02fb35c</a></p><p><a href="https://www.cnblogs.com/dsj2016/p/5714921.html">JAVA锁的膨胀过程和优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/133319319">聊聊Java 锁的JVM锁</a></p><p><a href="https://xinghelanchen.github.io/2018/08/22/JAVA%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B%E5%92%8C%E4%BC%98%E5%8C%96/">JAVA锁的膨胀过程和优化</a></p><h4 id="Lock-volatile"><a href="#Lock-volatile" class="headerlink" title="Lock + volatile"></a>Lock + volatile</h4><p>lock 的话主要是利用 AQS 框架来实现的同步机制。</p><p>AQS 框架内部利用了 CAS 来判断是否有线程持有锁。当有其他线程持有锁的时候，会 block 当前线程，然后入队列(入队的时候可能会有自旋)，当持有锁的线程释放锁后，会唤醒 block 的线程。</p><p>CAS 是 Java 提供的原子性操作 API 。</p><p>AQS 框架的理解：</p><pre><code class="java">acquire 独占式获取锁，如果没有获取成功，就入队列并阻塞。tryAcquire 独占式锁子类需要复写的方法，独占式请求锁。返回 true 表示线程获取锁成功，false 表示获取锁失败。acquireShare 共享式获取锁，当获取锁的线程数量超过指定数量(tryAcquireShare的返回结果小于0)，就阻塞尝试获取锁的线程。tryAcquireShare 共享式锁子类需要复写的方法。返回值如果小于 0 表示共享锁的数量消耗完，需要阻塞。acquireQueued 独占的时候，入队列addWaiter  具体的入队列入口doAcquireShared 共享的时候，入队列</code></pre><h3 id="Java-里锁的分类"><a href="#Java-里锁的分类" class="headerlink" title="Java 里锁的分类"></a>Java 里锁的分类</h3><ul><li>公平/非公平锁</li></ul><p>公平：按照请求锁的时间顺序依次获取锁，非公平锁就是不一定是按照请求锁的时间顺序来获取锁的。</p><ul><li>独占/共享锁</li></ul><p>独占锁(ReentrantLock)就是锁只能同时被一个线程持有，共享锁(CountDownLatch/Semaphone)就是锁可以同时被多个线程持有。</p><ul><li>自旋锁</li></ul><p>没有请求到锁的时候，做一段循环，等待持有锁的线程释放锁，然后请求锁。坏处就是，如果自旋过久，也会消耗大量的 cpu 资源。</p><ul><li>偏向锁/轻量锁/重量锁</li></ul><p>synchornized 的优化，如果再偏向锁发生竞争的时候会锁膨胀</p><ul><li>可重入/不可重入</li></ul><p>线程获取某个锁后，再次请求这个锁，仍然可以获取锁就是可重入锁。<br>反之，获取锁后，再次请求这个锁，无法获取到锁就是不可重入锁。</p><ul><li>可中断锁</li></ul><p>这个待完善。</p><h3 id="常用锁的原理分析"><a href="#常用锁的原理分析" class="headerlink" title="常用锁的原理分析"></a>常用锁的原理分析</h3><ul><li>ReentrantLock</li></ul><p>可重入锁，独占式的，默认是非公平锁，可通过构造方法来决定是公平锁还是非公平锁。</p><p>调用 lock 方法去尝试获取锁。</p><p>调用 unlock 方法释放锁。</p><ul><li>CountDownLatch</li></ul><p><code>await</code> 方法，调用此方法的时候，只有当 state 为 0 的时候才不阻塞，state 为其他值的情况下会阻塞线程</p><p>CountDownLatch 构造方法需要指定 count , 也就是 state</p><p><code>countDown</code> 方法，会使 count - 1 ，其实就是 count ，当  count - 1 == 0 的时候唤醒阻塞的线程。</p><p>适用于事情开始前，一些条件达成(条件达成，计数器减一)，然后继续。</p><p>需要注意的是 count 只有减少的方法，没有增加和重置的方法，故不可复用。</p><ul><li>CyclicBarrier </li></ul><p>强调的是，事情做完后，等其他线程也达到同等条件，然后在继续执行。</p><p>适用于事情做完后，等待某一条件达成，然后继续。</p><ul><li>ReentrantReadWriteLock</li></ul><p>里面包含读锁和写锁。读读不互斥，读写，写写互斥。就是两个线程都读数据的时候，不会阻塞，两个或者多个线程读写或者写写的时候会阻塞线程。</p><p>相对其他的锁，锁的粒度更小，效率会高一些，同样的，实现会复杂些。</p><p>默认是非公平锁，同样可以通过构造方法控制是否为公平锁。</p><p>read 锁为共享锁</p><p>write 锁为独占锁</p><p>这两个锁共用一个 AQS 框架的 state , state 高16位表示共享锁的 state , 低 16 为表示 write 锁的 state</p><ul><li>AQS 框架小结</li></ul><p>上面的四种框架很好的利用了 AQS 框架，重点基本在 <code>tryAcquire</code>、<code>tryAcquireShare</code> 里面，这 2 个方法的返回值是子类控制AQS框架是否阻塞线程的入口，如果需要自定义一种锁的话，需要好好设计这两个方法。 ReentrantReadWriteLock 就是一个很好的例子。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>这种互相通信的过程就是线程间的协作</p><p>多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同</p><p>线程间通信方式</p><ol><li>wait/notify </li></ol><p>synchornized 的时候，通过 wait/notify 来暂停线程和通知线程，从而达到通信的目的。</p><pre><code class="java">Object 类的方法，final 的，表示子类不可修改wait(long time)  主动释放锁，然后休眠，在指定的时间长度后自动唤醒或者被系统唤醒。notify() 随机唤醒一个等待的线程进入就绪队列notifyAll() 唤醒所有等待的线程进入就绪队列</code></pre><p>参考资料</p><p><a href="https://blog.csdn.net/u011635492/article/details/83043212">JAVA线程通信详解</a></p><p><a href="https://blog.csdn.net/bohu83/article/details/51098106">java condition使用及分析</a></p><ol start="2"><li>lock/condition</li></ol><p>这个其实和 wait/notify  类似，不过这个是语言层面实现的，不是虚拟机层面的实现。</p><ol start="3"><li>管道 </li></ol><p>PipedInputStream/PipedOutputStream 来实现的，一个是开始，一个是结束。</p><p>Object 和 Thread 常用方法介绍</p><pre><code class="java">Object: 下面的方法都只能在同步块中调用wait()  释放锁资源，并等待唤醒wait(long time)  释放锁资源，并在指定事件后唤醒notify()  随机唤醒一个线程进入就绪列表notifyAll() 唤醒所有线程进入就绪列表</code></pre><pre><code class="java">Thread: 类方法sleep(long time) 让线程休眠指定事件，但是不释放锁资源。join() 等待目标线程结束</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>通过 ThreadPoolExcutor 类来创建线程池。</p><p>创建线程池 5 个参数的含义</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程</td></tr><tr><td>maximumPoolSize</td><td>线程池中允许的最大线程数，只有工作队列满了，才可能继续创建线程，但是同时运行的线程数不会超过这个</td></tr><tr><td>keepAliveTime</td><td>当 idle 的线程数大于 corePoolSize 时，idle 的线程可以存活的时间。</td></tr><tr><td>unit</td><td>时间单位</td></tr><tr><td>workQueue</td><td>没有被执行的任务会放到这个队列里面</td></tr><tr><td>threadFactory</td><td>用来创建新的线程的</td></tr><tr><td>handler</td><td></td></tr></tbody></table><p>参考资料</p><p><a href="https://www.cnblogs.com/frankyou/p/10135212.html">理解ThreadPoolExecutor线程池的corePoolSize、maximumPoolSize和poolSize</a></p><p><a href="https://juejin.im/post/6844903909178212359">探索 Android 多线程优化方法</a></p><p><a href="https://juejin.im/post/6855586076132655118">一次Android线程优化的探索</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发总结笔记(四) - JVM 总结</title>
      <link href="/android-note/2021/02/26/android_note/android_note_04/"/>
      <url>/android-note/2021/02/26/android_note/android_note_04/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-总结"><a href="#JVM-总结" class="headerlink" title="JVM 总结"></a>JVM 总结</h1><h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h2><p>JVM 是 Java 虚拟机，是一个虚拟出来的计算机，仿真模拟计算机。</p><h2 id="JVM-在运行程序的时候，这个程序在-JVM-里面是怎么样的？"><a href="#JVM-在运行程序的时候，这个程序在-JVM-里面是怎么样的？" class="headerlink" title="JVM 在运行程序的时候，这个程序在 JVM 里面是怎么样的？"></a>JVM 在运行程序的时候，这个程序在 JVM 里面是怎么样的？</h2><p><strong>JVM</strong> 的内存主要分为五块</p><ol><li><strong>程序计算器</strong></li></ol><p>程序计算器是用来记录当前线程的执行的位置，通过程序计数器的记录，程序就可以继续进行下去。</p><p><strong>线程私有</strong>的，就是每个线程都不一样。</p><p>需要注意的是这里面没有 <code>OutOfMemory</code> 的异常，在执行 <code>native</code> 方法的时候，记录是空值，一些循环，比如 <code>for</code> 、 <code>while</code> 也是通过这个来实现的。</p><ol start="2"><li><strong>虚拟机栈</strong></li></ol><p>每一个线程都会有一个虚拟机栈，用于解释代码的执行过程。线程每调用一个方法的时候就会创建一个栈帧，并放到这个虚拟机栈中，方法执行完成后，这个栈帧出栈。</p><p>栈帧是什么呢？或者说里面是什么内容呢？栈帧主要包括以下 4 个内容：</p><ul><li>**局部变量表(LocalVariableTable)**，里面是这个方法里面的用到的变量，this 是下标为 0 的变量 </li><li><strong>操作数栈</strong>，JVM 是基于栈的，操作数可以理解为中间的计算结果，结果是保存在栈里面的。</li><li><strong>动态链接</strong>，在加载类的时候，类的字段和方法对应的内存布局之间的连接。</li><li><strong>返回值</strong>，方法的返回值</li></ul><p><strong>线程私有</strong>的，就是每个线程都不一样。</p><ol start="3"><li><strong>本地方法栈</strong></li></ol><p>和虚拟机栈类型，不过这里面具体就要看 native 层的了。</p><p><strong>线程私有</strong>的，就是每个线程都不一样。</p><ol start="4"><li><strong>方法区</strong></li></ol><p>类被加载后，类的属性、方法等信息会保存在这里。</p><ol start="5"><li><strong>堆</strong></li></ol><p>一般 new 出来的实例都是放在这里的。其他的部分在方法区里面的常量池。</p><p>那，哪些不在堆里面呢？？？</p><p>那些不在堆里面分配的对象实例可能在栈里面，具体的就哟啊说到逃逸分析了，这里</p><p><a href="https://juejin.im/post/6844904086010069006">https://juejin.im/post/6844904086010069006</a></p><p><a href="https://zhuanlan.zhihu.com/p/94568794">https://zhuanlan.zhihu.com/p/94568794</a></p><h2 id="一个-class-字节码文件里，类的结构是如何的？"><a href="#一个-class-字节码文件里，类的结构是如何的？" class="headerlink" title="一个 class 字节码文件里，类的结构是如何的？"></a>一个 class 字节码文件里，类的结构是如何的？</h2><p>类的结构可以粗略看出是一些无符号数和一些表组成的，表里面可以包含其他的表，大概的结构如下。</p><pre><code>魔数  大小版本号 常量池(表结构) 访问flag 父类  接口列表(表结构) 字段表(表结构) 方法表(表结构)  属性表(表结构)</code></pre><p>表结构由表的元素个数 count 和表的内容组成，表的内容可以是无符号数和表。不同的表，表的内容的每一项结构都是固定和相同的。</p><blockquote><p>常量池里面的每一项都是表</p></blockquote><h2 id="JVM-是如何找到一个类的"><a href="#JVM-是如何找到一个类的" class="headerlink" title="JVM 是如何找到一个类的"></a>JVM 是如何找到一个类的</h2><p>JVM 是通过 ClassLoader 来加载类的。</p><p>ClassLoader 的 loadClass 方法可以让系统找到一个类。</p><p>ClassLoader loadClass 的时候用到了双亲委派模式来加载一个类。先判断是否加载过，如果没有加载过，就先交给父类来加载，如果父类也没有加载过，再回到自己，自己去加载。</p><p>Java 里面的双亲委派并不是很强制的，可以通过复写 ClassLoader 的 loadClass 方法来破坏这种双亲委派模式，从而达到加载自己的类过程。</p><p>ClassLoader 加载类一般是从指定的路径下加载类的，双亲委派模型能保证先优先从顶层的类加载器来加载类，而顶层的类加载器一般是系统提供的，系统提供的类加载器都是加载的指定位置的类库，这样能保证系统类不被篡改。</p><p>另外 ClassLoader 的 defindClass 可以通过一个 byte 数组来定义一个类。</p><h2 id="JVM-加载类的时候，有哪些过程呢？"><a href="#JVM-加载类的时候，有哪些过程呢？" class="headerlink" title="JVM 加载类的时候，有哪些过程呢？"></a>JVM 加载类的时候，有哪些过程呢？</h2><p>类加载可以分为三大步(分别是，载入、连接和初始化)，也可以说是 5 个步骤。</p><p><img src="https://i.loli.net/2020/08/01/2i3va5CMtkwhWJH.jpg" class="lazyload placeholder" data-srcset="https://i.loli.net/2020/08/01/2i3va5CMtkwhWJH.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="类的生命周期"></p><p>类的加载过程：</p><ol><li><strong>加载</strong> 从二进制流加载类，主要做了三件事情</li></ol><ul><li>a. 通过类的全限定名查找 <code>.class</code> 文件，并生成二进制流</li><li>b. 解析 <code>.class</code> 文件，主要就是按照 <code>Class</code> 类的结构解析，生成 <code>JVM</code> 特定的数据结构并保存在<code>方法区</code>。</li><li>c. 生成一个 Class 类的实例，后续对这个类的访问可以通过这个 Class 的实例来完成。</li></ul><ol start="2"><li><strong>链接</strong>，可细分为一下三小步</li></ol><ul><li><ol><li>验证 校验版本号是否符合要求，高版本 class 不能在低版本 <code>JVM</code> 上运行</li></ol></li><li><ol start="2"><li>准备 给类的静态变量赋初始值，<code>final</code> 类型赋值。</li></ol></li><li><ol start="3"><li>解析 主要是把常量池里面的符号引用转为直接引用。</li></ol></li></ul><ol start="3"><li><strong>初始化</strong></li></ol><p>主要执行<code>静态代码块</code>、调用构造器的<code>构造方法</code>。</p><p>类的生命周期，除了加载过程中的 5 个阶段，还有<code>使用</code>和<code>卸载</code> 2 种阶段。</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>之前说过，每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。每个线程都是不一样的，还说过 JVM 是虚拟的一个硬件平台。那么 JVM 具体在执行一个线程的时候内存的情况是如何的呢？</p><p>线程工作的时候，会给线程分配一个内存空间，我们称之为工作内存，然后还有一个主内存。</p><p>线程在工作的时候， JVM  会先从主内存把数据载入工作内存，计算完成以后，在把最后的结果“写回”到主内存。</p><p>为什么要这样先载入最后写回？可能是因为载入的指令比较耗时吧。</p><h2 id="JVM-GC"><a href="#JVM-GC" class="headerlink" title="JVM GC"></a>JVM GC</h2><h3 id="四种索引"><a href="#四种索引" class="headerlink" title="四种索引"></a>四种索引</h3><ul><li>强引用。默认就是强引用，即使内存不够也不会释放。</li><li>软引用。SoftRefrence，内存不够的时候，会断开链接，然后释放内存。</li><li>弱引用。WeakRefrence，gc 的时候，如果发现了弱引用，就会释放，而不管是否内存不足。需要注意的是，可能需要多次 gc 才有可能找到这个弱引用，因为不同的 gc 清理或者说计算的内存区域不一样。</li><li>虚引用。代码里面无法直接使用。无法通过 get 方法获取引用对象。</li></ul><p>软引用和弱引用在创建的时候可同时传入一个ReferenceQueue，当引用的对象被回收的时候，ref 实例会被放到 Queue 里面。</p><h3 id="GC-的类型"><a href="#GC-的类型" class="headerlink" title="GC 的类型"></a>GC 的类型</h3><ul><li>GC_FOR_MALLOC 表示在堆上分配内存不足</li><li>GC_CONCURRENT 表示堆内存达到一定量的值，系统触发</li><li>GC_BEFOR_OOM 准备抛出 oom 异常</li><li>GC_EXPLICIT 调用系统方法  system.gc </li></ul><p><strong>软引用在前三个 gc 的时候释放，弱引用在创建后，下一次 gc 的时候释放。</strong></p><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h2 id="DVM-和-JVM-区别，或者说是如何优化的"><a href="#DVM-和-JVM-区别，或者说是如何优化的" class="headerlink" title="DVM  和 JVM 区别，或者说是如何优化的"></a>DVM  和 JVM 区别，或者说是如何优化的</h2><p>DVM 基于寄存器， JVM 基于栈</p><p>基于寄存器的优点是字节指令少，执行效率高，易优化，缺点就是实现复杂</p><p>基于栈的有点就是易移植，相对容易实现。缺点就是效率慢，指令多。</p><p><code>ART</code> 虚拟机是在 <code>DVM</code> 上做了优化。但还是基于寄存器的。</p><p><a href="https://www.cnblogs.com/qdhxhz/p/10646088.html">https://www.cnblogs.com/qdhxhz/p/10646088.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 GitHub 搭建自己的个人博客</title>
      <link href="/android-note/2021/02/25/blog/hexo_create_blog/"/>
      <url>/android-note/2021/02/25/blog/hexo_create_blog/</url>
      
        <content type="html"><![CDATA[<p>先看下预览图吧。</p><p><img src="https://img.imgdb.cn/item/6037cadc5f4313ce25858739.png" class="lazyload placeholder" data-srcset="https://img.imgdb.cn/item/6037cadc5f4313ce25858739.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="预览图"></p><p>先说下方案:</p><blockquote><p> GitHub Page + GitHub Action + hexo &amp; 配套主题 </p></blockquote><h1 id="GitHub-Page"><a href="#GitHub-Page" class="headerlink" title="GitHub Page"></a>GitHub Page</h1><p>这个都不陌生吧，注册 GitHub 账号后，可以帮你托管你的 <code>repository</code> 下的静态网页，比如我有个 <code>repository</code> 叫  <code>android-note</code> ，我的 github 账号叫 <code>xanderwang</code> ，那么我的 android-note 托管后，访问地址就是：</p><blockquote><p><a href="https://xander.github.io/android-note">https://xander.github.io/android-note</a></p></blockquote><p>托管后，如果我每次写了新的文章后，我把最新的静态 blog 上传上来，那么就可以更新自己的博客。</p><p>如果每次都可以自动编译和上传 blog 静态网页，那就很省事了。事实上，这个是可以做到的，具体细节后面再说。我们先看看如何托管我们的 <code>repository</code> 到 GitHub Page 。</p><p>最开始接触到 GitHub Page 的时候，看文章都是说需要新建一个和自己用户名同名的 <code>repository</code> ，然后往这个 <code>repository</code> 根目录里面上传静态 blog 网页，然后托管。</p><p>后来我发现不是这样，至少目前不是这样，我发现任意的 <code>repository</code> 都可以托管，只需要做一些特别的设置，如何设置呢？</p><p>找到你的 <code>repository</code> ，然后</p><blockquote><p>settings -&gt; GitHub Pages -&gt; Source -&gt; 选择分支和静态博客的目录(貌似只能选 <code>/</code> 或者 <code>/doc</code>)</p></blockquote><p>到这里 GitHub 托管就设置好了。按照之前的规则你就可以访问你托管 blog 了。</p><h1 id="GitHub-Action"><a href="#GitHub-Action" class="headerlink" title="GitHub Action"></a>GitHub Action</h1><p>刚刚说了，如果有个自动编译和上传 blog 的工具或者平台，每次我们写好 blog 后，自动帮我们编译上传好，那我们就可以省很多事。GitHub Action 正好可以做这个的，而且可以和 GitHub 无缝对接。那如何使用呢？</p><p>很简单，只需要在你的 <code>repository</code> 里面新建 <code>.github</code> 文件夹，然后在里面新建 <code>.workflows</code> 文件夹，然后在里面新建 <code>build.yml</code> 文件(build 可以换成任意你喜欢的)，然后 GitHub Action 功能就开通了。这个时候， <code>repository</code> 下的目录结构大概是</p><pre><code>.├── .github│   └── workflows│       └── build.yml</code></pre><p>现在介绍下如何配置 build.yml 文件</p><pre><code class="yml">name: Xander&#39;s Blog Task# 在push **.md **.yml **.yaml **.sh 文件后执行任务on: #配置任务执行时机  # Trigger the workflow on push or pull request,  # but only for the master branch  push:    # branches:        #   - master    paths:      - &#39;**.md&#39;      - &#39;**.yml&#39;      - &#39;**.yaml&#39;      - &#39;**.sh&#39;jobs: # 配置具体任务  build:    # runs-on: macOS-latest    runs-on: ubuntu-latest    steps:    # 引用外部 Action, 拉取代码仓库到虚拟机工作目录    - name: chekout code      uses: actions/checkout@v1    # 执行 .sh 脚本文件，很多的任务可以在这个脚本里面执行    - name: build note      run: sh ./blog_config/build.sh# ... 忽略其他内容</code></pre><p>上面列出了主要的步骤和解释了，具体可以参考<a href="https://github.com/XanderWang/android-note">我的 repository</a> </p><p>这里需要说明的是，如果你需要额外传一些参数，比如密码是的，你需要现在 repository 做一些设置，具体参考如下：</p><blockquote><p>settings -&gt; secrets -&gt; 新建一个 secret </p></blockquote><p>然后在你的 <code>build.yml</code> 里面使用</p><pre><code class="yml">steps:  - name: Hello world action    with: # Set the secret as an input      super_secret: $&#123;&#123; secrets.SuperSecret &#125;&#125;    env: # Or as an environment variable      super_secret: $&#123;&#123; secrets.SuperSecret &#125;&#125;    run: |      example-command &quot;$super_secret&quot;</code></pre><p>到这里自动编译和发布的工作就说完了，现在我们还缺什么？</p><h1 id="hexo-amp-配套主题"><a href="#hexo-amp-配套主题" class="headerlink" title="hexo &amp; 配套主题"></a>hexo &amp; 配套主题</h1><p>前面说了托管和自动编译和发布，现在我们就差一个个性化的静态 blog 模板了，这里我选择的是 hexo &amp; 配套主题。</p><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>这个是一个静态的博客构建软件，配合网络上的主题，可以比较方便构建出自己的博客，同时有大量的精美主题可以选择。</p><p>如何安装就不具体说了，不是很难，官网有很详细的教程。</p><p><a href="https://hexo.io/zh-cn/index.html">点我直达 hexo 官网</a></p><h2 id="hexo-配套主题"><a href="#hexo-配套主题" class="headerlink" title="hexo 配套主题"></a>hexo 配套主题</h2><p>主题的话，一般可以在 GitHub 上面找，我暂时用的 <a href="https://volantis.js.org/">volantis</a>，可以去官网看下这个主题的具体介绍和相关配置。</p><p>这里说下可能遇到的坑的，</p><p>这里说下 _config.yml</p><pre><code class="yml">...# URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: https://xanderwang.github.io/android-noteroot: /android-note/# 需要注意这里的配置，注意 url 和 root 的配置，如果不是用的 GitHub 同名 repository 托管的，都需要配置# Directorypublic_dir: docs      # 公共文件夹，这个文件夹用于存放生成的站点文件。# public_dir 目录就是 hexo 编译后存放静态 html 的目录，在托管 GitHub Page 的时候注意选择这个目录。...</code></pre><p>其他的配置就是主题配置了，这个建议按照注意的 repository 或者主题的 demo 去配置，每个主题都是不一样的，只能靠自己的折腾了。 </p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Action </tag>
            
            <tag> GitHub Page </tag>
            
            <tag> Gitee Page </tag>
            
            <tag> Gitee </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不会 Android 性能优化？你只差一个开源库！</title>
      <link href="/android-note/2021/02/24/android_performance/android_performance_lib/"/>
      <url>/android-note/2021/02/24/android_performance/android_performance_lib/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于本人工作需要，需要解决一些性能问题，虽然有 <code>Profiler</code> 、<code>Systrace</code> 等工具，但是无法实时监控，多少有些不方便，于是计划写一个能实时监控性能的小工具。经过学习大佬们的文章，最终完成了这个开源的性能实时检测库。初步能达到预期效果，这里做个记录，算是小结了。</p><p><a href="https://github.com/XanderWang/performance">开源库的地址是: https://github.com/XanderWang/performance</a></p><p>如果对你有帮助，幸苦小可爱能给个小小的 star 鼓励下。</p><p>这个性能检测库，可以检测以下问题：</p><ul><li><input checked="" disabled="" type="checkbox"> UI 线程 block 检测。</li><li><input checked="" disabled="" type="checkbox"> APP 的 FPS 检测。</li><li><input checked="" disabled="" type="checkbox"> 线程的创建和启动监控以及线程池的创建监控。</li><li><input checked="" disabled="" type="checkbox"> IPC (进程间通讯)监控。</li></ul><p>同时还实现了以下功能：</p><ul><li><input checked="" disabled="" type="checkbox"> 实时通过 logcat 打印检测到的问题。</li><li><input checked="" disabled="" type="checkbox"> 保存检测到的信息到文件。</li><li><input checked="" disabled="" type="checkbox"> 提供上报信息文件接口。</li></ul><h1 id="接入指南"><a href="#接入指南" class="headerlink" title="接入指南"></a>接入指南</h1><p>1 在 <code>APP</code> 工程目录下面的 <code>build.gradle</code> 添加如下内容。</p><pre><code class="groovy">dependencies &#123;  // 必选  debugImplementation &quot;com.xander.performance:perf:0.1.12&quot;  releaseImplementation &quot;com.xander.performance:perf-noop:0.1.12&quot;    // hook 方案封装，必须添加  debugImplementation &quot;com.xander.performance:perf-hook:0.1.12&quot;    // 以下是 hook 方案选择一个就好了。如果运行报错，就换另外一个，如果还是报错，就提个 issue  // SandHook 方案，推荐添加。如果运行报错，可以替换为 epic 库。  debugImplementation &quot;com.xander.performance:perf-hook-sandhook:0.1.12&quot;  // epic 方法。如果运行报错，可以替换为 SandHook。  // debugImplementation &quot;com.xander.performance:perf-hook-epic:0.1.12&quot;&#125;</code></pre><p>2 <code>APP</code> 工程的 <code>Application</code> 类新增类似如下初始化代码。</p><p>Java 初始化示例</p><pre><code class="java">  private void initPERF(final Context context) &#123;    final PERF.LogFileUploader logFileUploader = new PERF.LogFileUploader() &#123;      @Override      public boolean upload(File logFile) &#123;        return false;      &#125;    &#125;;    PERF.init(new PERF.Builder()        .checkUI(true, 100) // 检查 ui lock        .checkIPC(true) // 检查 ipc 调用        .checkFps(true, 1000) // 检查 fps        .checkThread(true) // 检查线程和线程池        .globalTag(&quot;test_perf&quot;) // 全局 logcat tag ,方便过滤        .cacheDirSupplier(new PERF.IssueSupplier&lt;File&gt;() &#123;          @Override          public File get() &#123;            // issue 文件保存目录            return context.getCacheDir();          &#125;        &#125;)        .maxCacheSizeSupplier(new PERF.IssueSupplier&lt;Integer&gt;() &#123;          @Override          public Integer get() &#123;            // issue 文件最大占用存储空间            return 10 * 1024 * 1024;          &#125;        &#125;)        .uploaderSupplier(new PERF.IssueSupplier&lt;PERF.LogFileUploader&gt;() &#123;          @Override          public PERF.LogFileUploader get() &#123;            // issue 文件上传接口            return logFileUploader;          &#125;        &#125;)        .build());  &#125;</code></pre><p>kotlin 示例</p><pre><code class="kotlin">  private fun doUpload(log: File): Boolean &#123;    return false  &#125;  private fun initPERF(context: Context) &#123;    PERF.init(PERF.Builder()        .checkUI(true, 100)// 检查 ui lock        .checkIPC(true) // 检查 ipc 调用        .checkFps(true, 1000) // 检查 fps        .checkThread(true)// 检查线程和线程池        .globalTag(&quot;test_perf&quot;)// 全局 logcat tag ,方便过滤        .cacheDirSupplier &#123; context.cacheDir &#125; // issue 文件保存目录        .maxCacheSizeSupplier &#123; 10 * 1024 * 1024 &#125; // issue 文件最大占用存储空间        .uploaderSupplier &#123; // issue 文件的上传接口实现          PERF.LogFileUploader &#123; logFile -&gt; doUpload(logFile) &#125;        &#125;        .build()    )  &#125;</code></pre><h1 id="主要更新记录"><a href="#主要更新记录" class="headerlink" title="主要更新记录"></a>主要更新记录</h1><ul><li>0.1.12 线程创建的监控，加入 thread name 信息收集。同时接入 startup 库做必要的初始化，以及调整 mulit dex 的时候，配置文件找不到的问题。</li><li>0.1.11 优化 hook 方案的封装，通过 SandHook ,IPC 的监控可以按照耗时时间来检测。</li><li>0.1.10 FPS 的检测时间间隔从默认 2s 调整为 1s，同时支持自定义时间间隔。</li><li>0.1.9  优化线程池创建的监控。</li><li>0.1.8  初版发布，完成基本的功能。</li></ul><p>不建议直接在线上使用这个库，在编写这个库，测试 hook 的时候，在不同的机器和 <code>rom</code> 上，会有不同的问题，这里建议先只在线下自测使用这个检测库。</p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><h2 id="UI-线程-block-检测原理"><a href="#UI-线程-block-检测原理" class="headerlink" title="UI 线程 block 检测原理"></a>UI 线程 block 检测原理</h2><p>主要参考了 <code>AndroidPerformanceMonitor</code> 库的思路，对 <code>UI</code> 线程的 <code>Looper</code> 里面处理 <code>Message</code> 的过程进行监控。</p><p>具体做法是，在 <code>Looper</code> 开始处理 <code>Message</code> 前，在异步线程开启一个延时任务，用于后续收集信息。如果这个 <code>Message</code> 在指定的时间段内完成了处理，那么在这个 <code>Message</code> 被处理完后，就取消之前的延时任务，说明 <code>UI</code> 线程没有 block 。如果在指定的时间段内没有完成任务，说明 <code>UI</code> 线程有 block 。此时，异步线程可以执行刚才的延时任务。如果我们在这个延时任务里面打印 <code>UI</code> 线程的方法调用栈，就可以知道 <code>UI</code> 线程在做什么了。这个就是 <code>UI</code>  线程 block 检测的基本原理。</p><p>但是这个方案有一个缺点，就是无法处理 <code>InputManager</code> 的输入事件，比如 <code>TV</code> 端的遥控按键事件。通过对按键事件的调用方法链进行分析，发现最终每个按键事件都调用了 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法，而非 <code>Looper</code> 的处理 <code>Message</code> 流程。所以 <code>AndroidPerformanceMonitor</code> 库是无法准确监控 TV 端应用 <code>UI</code>  block 的情况。针对 <code>TV</code> 端应用按键处理，需要找到一个新的切入点，这个切入点就是刚刚的 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法。</p><p>那如何介入 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法呢？我们可以通过 <code>epic</code> 库来 <code>hook</code> 这个方法的调用。<code>hook</code> 成功后，我们可以在 <code>DecorView</code> 类的 <code>dispatchKeyEvent</code> 方法调用前后都接收到一个回调方法，在 <code>dispatchKeyEvent</code> 方法调用前我们可以在异步线程执行一个延时任务，在 <code>dispatchKeyEvent</code> 方法调用后，取消这个延时任务。如果 <code>dispatchKeyEvent</code> 方法耗时时间小于指定的时间阈值，延时任务在执行前被取消，可以认为没有 block ，此时移除了延时任务。如果 <code>dispatchKeyEvent</code> 方法耗时时间大于指定的时间阈值说明此时 <code>UI</code>  线程是有 block 的。此时，异步线程可以执行这个延时任务来收集必要的信息。</p><p>以上就是修改后的 <code>UI</code> 线程 block 的检测原理了，目前做的还比较粗糙，后续计划考虑参考 <code>AndroidPerformanceMonitor</code> 打印 CPU 、内存等更多的信息。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_Issue: =================================================    type: UI BLOCK    msg: UI BLOCK    create time: 2021-01-13 11:24:41    trace:        java.lang.Thread.sleep(Thread.java:-2)        java.lang.Thread.sleep(Thread.java:442)        java.lang.Thread.sleep(Thread.java:358)        com.xander.performance.demo.MainActivity.testANR(MainActivity.kt:49)        java.lang.reflect.Method.invoke(Method.java:-2)        androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)        android.view.View.performClick(View.java:7496)        android.view.View.performClickInternal(View.java:7473)        android.view.View.access$3600(View.java:831)        android.view.View$PerformClick.run(View.java:28641)        android.os.Handler.handleCallback(Handler.java:938)        android.os.Handler.dispatchMessage(Handler.java:99)        android.os.Looper.loop(Looper.java:236)        android.app.ActivityThread.main(ActivityThread.java:7876)        java.lang.reflect.Method.invoke(Method.java:-2)        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</code></pre><h2 id="FPS-检测的原理"><a href="#FPS-检测的原理" class="headerlink" title="FPS 检测的原理"></a>FPS 检测的原理</h2><p>FPS 检测的原理，利用了 Android 的屏幕绘制原理。这里简单说下 Android 的屏幕绘制原理。</p><p>系统每隔 16 ms 就会发送一个 <code>VSync</code> 信号。 如果应用注册了这个 <code>VSync</code> 信号，就会在 <code>VSync </code> 信号到来的时候，收到回调，从而开始准备绘制。如果准备顺利，也就是 <code>CPU</code> 准备数据、<code>GPU</code> 栅格化等，如果这些任务在 16 ms 之内完成，那么下一个 <code>VSync</code> 信号到来前就可以绘制这一帧界面了。就没有掉帧，界面很流畅。如果在 16 ms 内没准备好，可能就需要更多的时间这个画面才能显示出来，在这种情况下就发生了丢帧，如果丢帧很多就卡顿了。</p><p>检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 了。那如何知道应用 1s 内绘制了多少个界面呢？这个就要靠 <code>VSync</code> 信号监听了。</p><p>在开始准备绘制前，往 <code>UI</code> 线程的 <code>MessageQueue</code> 里面放一个<strong>同步屏障</strong>，这样 <code>UI</code> 线程就只会处理异步消息，直到<strong>同步屏障</strong>被移除。刷新前，应用会注册一个 <code>VSync</code> 信号监听，当 <code>VSync</code> 信号到达的时候，系统会通知应用，让应用会给 <code>UI</code> 线程的 <code>MessageQueue</code> 里面放一个<strong>异步 <code>Message</code> <strong>。由于之前 <code>MessageQueue</code> 里有了一个</strong>同步屏障</strong>，所以后续 <code>UI</code> 线程会优先处理这个<strong>异步 <code>Message</code></strong> 。这个<strong>异步 <code>Message</code></strong> 做的事情就是从  <code>ViewRootImpl</code> 开始我们熟悉的 <code>measure</code> 、<code>layout</code> 和 <code>draw</code> 。</p><p>我们可以通过 <code>Choreographer</code> 注册 <code>VSync</code> 信号监听。16ms 后，我们收到了 <code>VSync</code> 的信号，给 <code>MessageQueue</code> 里面放一个<strong>同步消息</strong>，我们不做特别处理，只是做一个计数，然后监听下一次的 <code>VSync</code> 信号，这样，我们就可以知道 1s 内我们监听到了多少个 <code>VSync</code> 信号，就可以得出帧率。</p><p>为什么监听到的 <code>VSync</code> 信号数量就是帧率呢？</p><p>由于 <code>Looper</code> 处理 <code>Message</code> 是串行的，就是一次只处理一个 <code>Message</code> ，处理完了这个 <code>Message</code> 才会处理下一个 <code>Message</code> 。而绘制的时候，绘制任务 <code>Message</code> 是异步消息，会优先执行，绘制任务 <code>Message</code> 执行完成后，就会执行上面说的 <code>VSync</code> 信号计数的任务。如果忽略计数任务的耗时，那么最后统计到的 <code>VSync</code> 信号数量可以粗略认为是某段时间内绘制的帧数。然后就可以通过这段时间的长度和 <code>VSync</code> 信号数量来计算帧率了。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_FPSTool: APP FPS is: 54 Hzcom.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hzcom.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hz</code></pre><h2 id="线程的创建和启动监控以及线程池的创建监控"><a href="#线程的创建和启动监控以及线程池的创建监控" class="headerlink" title="线程的创建和启动监控以及线程池的创建监控"></a>线程的创建和启动监控以及线程池的创建监控</h2><p>线程和线程池的监控，主要是监控线程和线程池在哪里创建和执行的，如果我们可以知道这些信息，我们就可以比较清楚线程和线程池的创建和启动时机是否合理。从而得出优化方案。</p><p>一个比较容易想到的方法就是，应用代码里面的所有线程和线程池继承同一个线程基类和线程池基类。然后在构造函数和启动函数里面打印方法调用栈，这样我们就知道哪里创建和执行了线程或者线程池。</p><p>让应用所有的线程和线程池继承同一个基类，可以通过编译插件来实现，定制一个特殊的 <code>Transform</code> ，通过 <code>ASM</code> 编辑生成的字节码来改变继承关系。但是，这个方法有一定的上手难度，不太适合新手。</p><p>除了这个方法，我们还有另外一种方法，就是 <code>hook</code> 。通过 <code>hook</code> 线程或者线程池的构造方法和启动方法，我们就可以在线程或者线程池的构造方法和启动方法的前后做一些切片处理，比如打印当前方法调用栈等。这个也就是线程和线程池监控的基本原理。</p><p>线程池的监控没有太大难度，一般都是 <code>ThreadPoolExecutor</code> 的子类，所以我们 <code>hook</code> 一下 <code>ThreadPoolExecutor</code> 的构造方法就可以监控线程池的创建了。线程池的执行主要就是 <code>hook</code> 住 <code>ThreadPoolExecutor</code> 类的 <code>execute</code> 方法。</p><p>线程的创建和执行的监控方法就稍微要费些脑筋了，因为线程池里面会创建线程，所以这个线程的创建和执行应该和线程池绑定的。需要找到线程和线程池的联系，之前看到一个库，好像是通过线程和线程池的 <code>ThreadGroup</code> 来建立关联的，本来我也计划按照这个关系来写代码的，但是我发现，我们有的小伙伴写的线程池的 <code>ThreadFactory</code> 里面创建线程并没有传入<code>ThreadGroup</code> ，这个就尴尬了，就建立不了联系了。经过查阅相关源码发现了一个关键的类，<code>ThreadPoolExecutor</code> 的内部类<code>Worker</code> ，由于这个类是内部类，所以这个类实际的构造方法里面会传入一个外部类的实例，也就是 <code>ThreadPoolExecutor</code> 实例。同时， <code>Worker</code> 这个类还是一个 <code>Runnable</code> 实现，在 <code>Worker</code> 类通过 <code>ThreadFactory</code> 创建线程的时候，会把自己作为一个 <code>Runnable</code> 传给 <code>Thread</code> 所以，我们通过这个关系，就可以知道 <code>Worker</code> 和 <code>Thread</code> 的关联了。这样，我们通过 <code>ThreadPoolExecutor</code> 和 <code>Worker</code> 的关联，以及 <code>Worker</code> 和 <code>Thread</code> 的关联，就可以得到 <code>ThreadPoolExecutor</code> 和它创建的 <code>Thread</code> 的关联了。这个也就是线程和线程池的监控原理了。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_Issue: =================================================    type: THREAD    msg: THREAD POOL CREATE    create time: 2021-01-13 11:23:47    create trace:        com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39)        com.xander.performance.ThreadTool$ThreadPoolExecutorConstructorHook.afterHookedMethod(ThreadTool.java:158)        de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:265)        me.weishu.epic.art.entry.Entry64.onHookObject(Entry64.java:64)        me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:239)        java.util.concurrent.Executors.newSingleThreadExecutor(Executors.java:179)        com.xander.performance.demo.MainActivity.testThreadPool(MainActivity.kt:38)        java.lang.reflect.Method.invoke(Method.java:-2)        androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)        android.view.View.performClick(View.java:7496)        android.view.View.performClickInternal(View.java:7473)        android.view.View.access$3600(View.java:831)        android.view.View$PerformClick.run(View.java:28641)        android.os.Handler.handleCallback(Handler.java:938)        android.os.Handler.dispatchMessage(Handler.java:99)        android.os.Looper.loop(Looper.java:236)        android.app.ActivityThread.main(ActivityThread.java:7876)        java.lang.reflect.Method.invoke(Method.java:-2)        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</code></pre><h2 id="IPC-进程间通讯-监控的原理"><a href="#IPC-进程间通讯-监控的原理" class="headerlink" title="IPC(进程间通讯)监控的原理"></a>IPC(进程间通讯)监控的原理</h2><p>进程间通讯的具体原理，也就是 <code>Binder</code> 机制，这里不做详细的说明，也不是这个框架库的原理。</p><p>检测进程间通讯的方法和前面检测线程的方法类似，就是找到所有的进程间通讯的方法的共同点，然后对共同点做一些修改或者说切片，让应用在进行进程间通讯的时候，打印一下调用栈，然后继续做原来的事情。就达到了 IPC 监控的目的。</p><p>那如何找到共同点，或者说切片，就是本节的重点。</p><p>进程间通讯离不开 <code>Binder</code> ，需要从 <code>Binder</code> 入手。</p><p>写一个 <code>AIDL</code> demo 后发现，自动生成的代码里面，接口 <code>A</code> 继承自 <code>IInterface</code> 接口，然后接口里面有个内部抽象类 <code>Stub</code> 类，继承自 <code>Binder</code> ，同时实现了接口 <code>A</code> 。这个 <code>Stub</code> 类里面还有一个内部类 <code>Proxy</code> ，实现了接口 <code>A</code> ，并持有一个 <code>IBinder</code> 实例。</p><p>我们在使用 <code>AIDL</code> 的时候，会用到 <code>Stub</code> 类的 <code>asInterFace</code> 的方法，这个方法会新建一个 <code>Proxy</code> 实例，并给这个 <code>Proxy</code> 实例传入 <code>IBinder</code> , 或者如果传入的 <code>IBinder</code> 实例如果是接口 <code>A</code> 的话，就强制转化为接口 A 实例。一般而言，这个 <code>IBinder</code> 实例是 <code>ServiceConnection</code> 的回调方法里面的实例，是 <code>BinderProxy</code> 的实例。所以 <code>Stub</code> 类的 <code>asInterFace</code> 一般会创建一个 <code>Proxy</code> 实例，查看这个 <code>Proxy</code> 接口的实现方法，发现最终都会调用 <code>BinderProxy</code> 的 <code>transact</code> 方法，所以 <code>BinderProxy</code> 的 <code>transact</code> 方法是一个很好的切入点。</p><p>本来我也是计划通过 <code>hook</code> 住 <code>BinderProxy</code> 类的 <code>transact</code> 方法来做 IPC 的检测的。但是 <code>epic</code> 库在 <code>hook</code> 含有 <code>Parcel</code> 类型参数的方法的时候，不稳定，会有异常。由于暂时还没能力解决这个异常，只能重新找切入点。最后发现 <code>AIDL</code> demo 生成的代码里面，除了调用了 调用 <code>BinderProxy</code> 的 <code>transact</code> 方法外，还调用了 <code>Parcel</code> 的 <code>readException</code> 方法，于是决定 <code>hook</code> 这个方法来切入 <code>IPC</code> 调用流程，从而达到 <code>IPC</code> 监控的目的。</p><p>最终终端 log 打印效果如下：</p><pre><code>com.xander.performace.demo W/demo_Issue: =================================================    type: IPC    msg: IPC    create time: 2021-01-13 11:25:04    trace:        com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39)        com.xander.performance.IPCTool$ParcelReadExceptionHook.beforeHookedMethod(IPCTool.java:96)        de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:229)        me.weishu.epic.art.entry.Entry64.onHookVoid(Entry64.java:68)        me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:220)        me.weishu.epic.art.entry.Entry64.voidBridge(Entry64.java:82)        android.app.IActivityManager$Stub$Proxy.getRunningAppProcesses(IActivityManager.java:7285)        android.app.ActivityManager.getRunningAppProcesses(ActivityManager.java:3684)        com.xander.performance.demo.MainActivity.testIPC(MainActivity.kt:55)        java.lang.reflect.Method.invoke(Method.java:-2)        androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)        android.view.View.performClick(View.java:7496)        android.view.View.performClickInternal(View.java:7473)        android.view.View.access$3600(View.java:831)        android.view.View$PerformClick.run(View.java:28641)        android.os.Handler.handleCallback(Handler.java:938)        android.os.Handler.dispatchMessage(Handler.java:99)        android.os.Looper.loop(Looper.java:236)        android.app.ActivityThread.main(ActivityThread.java:7876)        java.lang.reflect.Method.invoke(Method.java:-2)        com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656)        com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967)</code></pre><h1 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h1><ul><li> Mail</li></ul><p><a href="mailto:&#x34;&#50;&#x30;&#54;&#x34;&#x30;&#x37;&#54;&#51;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;">&#x34;&#50;&#x30;&#54;&#x34;&#x30;&#x37;&#54;&#51;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a></p><ul><li>微信</li></ul><p><img src="https://s3.ax1x.com/2021/01/30/yASVMD.jpg" class="lazyload placeholder" data-srcset="https://s3.ax1x.com/2021/01/30/yASVMD.jpg" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="微信"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h1><ol><li><a href="https://github.com/tiann/epic">epic</a></li><li><a href="https://github.com/ganyao114/SandHook">SandHook</a></li><li><a href="https://github.com/markzhai/AndroidPerformanceMonitor">AndroidPerformanceMonitor</a></li><li><a href="https://juejin.cn/post/6890407553457963022">面试官：如何监测应用的 FPS ？</a></li><li><a href="https://juejin.cn/post/6844904066259091469">深入探索Android卡顿优化（下）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发总结笔记(三) - Java 集合总结</title>
      <link href="/android-note/2021/02/07/android_note/android_note_03/"/>
      <url>/android-note/2021/02/07/android_note/android_note_03/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合总结"><a href="#Java-集合总结" class="headerlink" title="Java 集合总结"></a>Java 集合总结</h1><h2 id="Java-有哪些集合，继承关系是怎么样的"><a href="#Java-有哪些集合，继承关系是怎么样的" class="headerlink" title="Java 有哪些集合，继承关系是怎么样的"></a>Java 有哪些集合，继承关系是怎么样的</h2><p><img src="https://i.loli.net/2020/06/25/1WJPcAhjOQtyINo.png" class="lazyload placeholder" data-srcset="https://i.loli.net/2020/06/25/1WJPcAhjOQtyINo.png" srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@3/img/placeholder/c617bfd2497fcea598e621413e315c368f8d8e.svg" alt="集合框架图"></p><h2 id="平时常用的集合有哪些"><a href="#平时常用的集合有哪些" class="headerlink" title="平时常用的集合有哪些"></a>平时常用的集合有哪些</h2><ul><li>Collection<ul><li>List 可以重复添加元素<ul><li>ArrayList</li><li>LinkedList</li></ul></li><li>Set 不能重复添加元素<ul><li>HashSet 不接受 null </li><li>TreeSet</li></ul></li><li>Queue<ul><li>Deque</li><li>PriorityQueue 数组实现，堆</li><li>ArrayDeque 数组实现， 2 个游标</li></ul></li></ul></li><li>Map 以键值对的形式保存值<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>TreeMap</li><li>Hashtable</li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>数组实现，初始容量为 10，不够的时候扩容，扩容就是数组在当前长度基础上增大一倍。添加数据的时候，先判断容量是否够，不够就扩容，扩容完成后再添加。</p><p>缺点: 线程不安全</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>链表实现。尾插法，即新节点插入到链表尾部。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>Java 1.8 底层基于 <code>HashMap</code> 实现，<code>HashMap</code> 的 <code>value</code> 都是同一个对象。</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>Java 1.8 默认是 <code>TreeMap</code> 实现，也可以给构造方法传入一个  <code>NavigableMap(接口)</code> 的实现实例。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>双端队列，</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>堆，数组实现的</p><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>最常用的一种结构，以数组为基础，数组元素为链表的复合结构。</p><p>需要注意的是：</p><blockquote><p>初始容量为 16，默认承载因子为 0.75 ，需要注意的是，在指定容量的时候，如果不是 2 的指数，会计算一个大于指定容量，但是同时又是符合要求里面最小的一个 2 的指数作为容量。</p></blockquote><blockquote><p>当元素个数大于或等于(当前容量 * 承载因子)，就会扩容。</p></blockquote><blockquote><p>Java 1.7 插入数据的时候是头插法，即新的节点在链表头部。Java 1.8 及以后是尾插法，即新的节点在链表尾部。这个修改是为了解决扩容的时候可能会发生的死循环的问题。</p></blockquote><blockquote><p>Java 1.8 及以后，当同一个链表元素个数大于等于 (8 - 1) 的时候，会变成红黑树来存储，目的是提高效率。红黑树的转变是先比较 key 的 hash 大小，如果相同就尝试比较 key 自身。</p></blockquote><blockquote><p>无论是扩容，还是转成红黑树，都是先把节点放进去后再做扩容或者转换。</p></blockquote><blockquote><p>hash 碰撞，是指不同的 key, key 的 hash 和数组大小再次计算后,得出的索引一致。 hash 碰撞越少，HashMap 的效率越高。1.7 和 1.8 hash 算法有区别。</p></blockquote><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>基于 <code>HashMap</code> 实现的，同时还是一个双向循环链表(比 HashMap 的节点多了个 before 和 after 指针)，在开启排序的情况下，最近使用过的节点(put、get)会放在链表尾部。</p><p>这个特性很适合 <code>LRU</code> 算法的实现，大概原理就是 <code>LinkedHashMap</code> 开启排序，然后最近使用的元素都在链表<strong>尾部</strong>，当链表长度大于指定长度的时候，就从链表头部开始删除，因为链表头部是最近没有使用的。</p><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p><code>synchroinzed</code> 实现线程安全，效率低下。</p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 在 Java 1.8 底层实现是一个<strong>红黑树</strong>，排序的规则是比较 key 的 “大小”。并且要求 key 的类型是需要可以比较的，并且 key 值不能为 null。</p><p>和 <code>HashMap</code> 一样，先插入数据，然后在重排序。</p><h2 id="碰到的常见问题"><a href="#碰到的常见问题" class="headerlink" title="碰到的常见问题"></a>碰到的常见问题</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>由于以上的都不是线程安全的，所以多线程的时候容易出问题，对于安全的线程有以下的几种</p><ul><li>List<ul><li>Vector 通过方法添加 <code>synchizoned</code> 关键字实现，效率低下。</li><li>CopyOnWriteArrayList <strong>每次</strong><code>写(添加，删除，修改)</code>的时候，都会生成一个新副本，所以频繁的写操作会消耗大量内存。</li></ul></li><li>Set<ul><li>CopyOnWriteArraySet 类似 CopyOnWriteArrayList</li></ul></li><li>Map<ul><li>ConcurrentHashMap  Java 1.7 是通过分段锁实现，Java 1.8 是 <code>CAS</code> 和 <code>synchroinzed</code> 实现</li></ul></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>分段锁来实现，分段锁可以提高效率，是因为如果不同线程的读写发生在不同的段上，实际上是没有锁竞争的，也就是没有线程被阻塞，所以效率高。</p><h4 id="Java-1-7-及以前实现原理"><a href="#Java-1-7-及以前实现原理" class="headerlink" title="Java 1.7 及以前实现原理"></a>Java 1.7 及以前实现原理</h4><p>ConcurrentHashMap 有一个 segments 数组，这个数组元素的类型是 Segment，它继承自 ReentrantLock ，也就是说 Segment 是一个锁。</p><p>ConcurrentHashMap 插入或者修改数据的时候，会先找到是哪一个 segment , 然后在这个 segment 上面插入或者修改数据，而 segment 插入或者修改数据的时候，会先尝试获取锁，如果获取失败，说明有锁竞争，然后先尝试自旋，自旋超过次后，就开始阻塞线程。因此是线程安全的。</p><p>另外需要注意的是获取数据的时候没有加锁，因为是 <code>volatile</code> 变量，可以拿到最新的数据，但是呢，</p><h4 id="Java-1-8-及以后实现原理"><a href="#Java-1-8-及以后实现原理" class="headerlink" title="Java 1.8 及以后实现原理"></a>Java 1.8 及以后实现原理</h4><p>类似 HashMap ,放弃了分段锁，在插入或者修改数据的时候利用 cas 和 synchionzed 来保证线程安全，大概的原理就是先利用 cas 来设置，设置失败的时候说明有线程竞争，这个时候就用  synchionzed 来加锁，保证线程安全。</p><h4 id="Java-1-8-之后，为何放弃了分段锁"><a href="#Java-1-8-之后，为何放弃了分段锁" class="headerlink" title="Java 1.8 之后，为何放弃了分段锁"></a>Java 1.8 之后，为何放弃了分段锁</h4><p>分段后，数据不连续，碎片较多，内存浪费严重，扩容等操作耗费大量的时间。</p><p>Java 1.8 是用的 synchornized + HashMap 来做的， synchornized jvm 层做了优化，同时 HashMap 也做了红黑树的优化，所以效率方面有保障。</p><h2 id="主要方法总结"><a href="#主要方法总结" class="headerlink" title="主要方法总结"></a>主要方法总结</h2><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><pre><code>- add(E):boolean- add(int, E):boolean- remove(int):E- remove(E):boolean- size():int</code></pre><h4 id="Stack-类"><a href="#Stack-类" class="headerlink" title="Stack 类"></a>Stack 类</h4><p>继承自 Vector , Vector 是一个同步安全的 List</p><pre><code>- push(E):E 入栈- pop():E 出栈- peek():E 查看顶部第一个元素- search(Object):int- empty() 是否是空的</code></pre><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><pre><code>- add(E):boolean- contains(Object):boolean- remove(Object):boolean- size():int</code></pre><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><pre><code>- add 添加元素，返回添加结果，如果不能添加就抛出异常- remove 删除队列头，空队列异常- element 返回队列头，空队列异常- offer 添加元素，返回添加结果- poll 返回并删除队列头，空队列的话返回 null- peek 返回队列头，空队列的话返回 null</code></pre><h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><pre><code>- put(K, V):V- remove(Object):V- containsKey(Object):boolean- containsValue(Object):boolean- size():int</code></pre><h3 id="ArrayMap-和-HashMap"><a href="#ArrayMap-和-HashMap" class="headerlink" title="ArrayMap 和 HashMap"></a>ArrayMap 和 HashMap</h3><p>ArrayMap 有缓存， HashMap 没有</p><p>内存小</p><p><a href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a></p><p>SparseArray 和 ArrayList</p>]]></content>
      
      
      <categories>
          
          <category> 总结笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发总结笔记(二) - Java 反射和注解总结</title>
      <link href="/android-note/2021/02/07/android_note/android_note_02/"/>
      <url>/android-note/2021/02/07/android_note/android_note_02/</url>
      
        <content type="html"><![CDATA[<h1 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>反射是 Java 语言的一个特性，就是在程序运行状态中，对于任何一个类，都可以通过反射知道这个类所有的方法和属性。对于任何一个实例，都可以调用这个实例的任何方法和属性。这个<strong>在运行时动态获取类或者实例的属性和方法，动态调用属性和方法的特性</strong>就叫反射。</p><h2 id="反射有什么用"><a href="#反射有什么用" class="headerlink" title="反射有什么用"></a>反射有什么用</h2><p>从特性可以看出，在运行时可以动态调整属性的值和调用代码，可以让程序更灵活。主要用于以下几点</p><ul><li>动态创建实例( class.newInstance 方法 )</li><li>调用某个方法( method.invoke 方法 )</li><li>修改或者获取某个字段的值</li></ul><h3 id="反射的常用方法介绍"><a href="#反射的常用方法介绍" class="headerlink" title="反射的常用方法介绍"></a>反射的常用方法介绍</h3><h4 id="Class-常用方法介绍"><a href="#Class-常用方法介绍" class="headerlink" title="Class 常用方法介绍"></a>Class 常用方法介绍</h4><pre><code>getDeclaringClass  一般针对内部类，如 B 是 A 的内部类，在 B 的 class 上调用这个方法，返回的是 A getDeclaredClasses 获取当前类声明的内部类getClasses  包含当前类的父类和声明的 public 的内部类newInstance  创建一个类的实例forName 获取一个类，如果类没有加载会加载getConstructor 系列方法，可以获取构造方法类实例，然后调用实例的 newInstance 方法可以获得一个实例</code></pre><h4 id="Method-常用方法介绍"><a href="#Method-常用方法介绍" class="headerlink" title="Method 常用方法介绍"></a>Method 常用方法介绍</h4><pre><code>getMethod  获取 public 的方法，包括继承的getDeclaredMethod  该类里面的定义的方法，包括私有的和实现的接口的方法。invoke 该方法可以调用某个实例的某个方法。第一个参数为 null 时表示调用静态方法，第一个参数传入某个实例的时候，表示调用实例的某个方法。</code></pre><h4 id="Filed-常用方法介绍"><a href="#Filed-常用方法介绍" class="headerlink" title="Filed 常用方法介绍"></a>Filed 常用方法介绍</h4><pre><code>getField 获取字段getDeclaredField </code></pre><h2 id="常用的场景"><a href="#常用的场景" class="headerlink" title="常用的场景"></a>常用的场景</h2><h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>可以通过 <code>Class.forName</code> 方法加载指定的配置类，然后读取配置，以达到动态配置的效果。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理底层用到了反射。</p><h3 id="hook-框架"><a href="#hook-框架" class="headerlink" title="hook 框架"></a>hook 框架</h3><p>动态生成实例，修改字段值、调用非 <code>public</code> 方法</p><p>参考资料：</p><p><a href="https://www.zhihu.com/question/24304289">学习java应该如何理解反射？</a></p><h1 id="注解总结"><a href="#注解总结" class="headerlink" title="注解总结"></a>注解总结</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解是 JDK 1.5 引入的一个特性，用来给 Java 代码提供元数据。注解本身不直接影响代码的执行。</p><p>如何理解呢？<strong>注解是 Java 的一个特性，元数据可以理解为给编译器或者 jvm 看的++注释++，不直接影响程序的运行</strong>。但是可以在运行时通过读取注解做一些事情。可以把元数据理解为额外的一些可用可不用的额外信息。</p><h3 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h3><p>和定义接口类似，只不过关键字是 <code>@interface</code>。下面一段代码演示了如何定义个注解</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;    int id();    String msg();&#125;</code></pre><h2 id="注解的应用场景"><a href="#注解的应用场景" class="headerlink" title="注解的应用场景"></a>注解的应用场景</h2><ul><li>提供信息给编译器  这个接触的不多</li><li>编译阶段的处理    比如生产文档，这个有时候会用</li><li>运行时的处理   这个相对用的多，就是说运行时读取注解的值，来做一些事情，比如 Retrofit  框架库，就用到了注解。具体的原理分析在后续笔记记录。</li></ul><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/37701743">java注解-最通俗易懂的讲解</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 反射 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发总结笔记(一) - 泛型总结</title>
      <link href="/android-note/2020/07/23/android_note/android_note_01/"/>
      <url>/android-note/2020/07/23/android_note/android_note_01/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型总结"><a href="#泛型总结" class="headerlink" title="泛型总结"></a>泛型总结</h1><h2 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h2><p>一句话说就是<strong>类型参数化</strong>。什么意思呢？<strong>参数化</strong>的意思就是我们在定义的时候不知道具体的值，我们在到我们实际运行的时候才知道具体的值。类型参数化就是具体类型在定义的时候不知道，在实际运行的时候是确定的某一个类型。</p><h2 id="Java-是如何实现泛型的？"><a href="#Java-是如何实现泛型的？" class="headerlink" title="Java 是如何实现泛型的？"></a>Java 是如何实现泛型的？</h2><p>泛型是很多高级语言都有的特性。根据定义，泛型在运行时表示同一个类型，我们比较容易想到 <code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 用 2 个不同的 Class 表示，这个是可行的，但是 Java 由于需要兼容支持旧的代码，而且在推出泛型前就提供了容器类，这种方式(<code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code> 用 2 个不同的 Class)无法兼容以前的老代码，所以这个实现方法不适用。所以 Java 大佬们想了另外一种方式来实现泛型,这种方式就是<code>类型擦除</code>。</p><h2 id="什么是泛型的类型擦除呢？"><a href="#什么是泛型的类型擦除呢？" class="headerlink" title="什么是泛型的类型擦除呢？"></a>什么是泛型的类型擦除呢？</h2><p>类型擦除就是在实际生成字节码的时候，编译器源码里面定义的 <code>List&lt;A&gt;</code> 变成了 <code>List&lt;Object&gt;</code>,源码里面定义的 <code>A Class</code> 被<code>擦除</code>了，变成了 <code>Object</code>，同时在使用的时候，会强制类型转换，把取出来的 <code>object</code> 转成 <code>A</code> 的实例去使用。这就是类型擦除。</p><p>初步看，泛型擦除好像是没什么大的问题，但是仔细想想，在强制类型转换的时候，由于会丢掉类型的一些信息，会导致一些不符合预期的事情。比如有个基类 A，和它的两个子类 B 和 C ，然后我们有下面的一段代码。</p><pre><code>List&lt;A&gt; listA = new ArrayList&lt;A&gt;();listA.add(new B()); // 错误的，</code></pre><p>第二行代码是不符合预期的，因为 <code>listA</code> 里面期望放的是 <code>A</code> 而不是 <code>B</code>。 但是这个好像不太符合预期，我们有时候希望子类是可以放进容器里面的。但是如果支持这个操作的话，会发生什么呢？取出来来的是 <code>B</code> 还是 <code>C</code> ？如果不能明确，那么就没有实现“泛型”。</p><p>为了解决这个问题， Java 大佬们想了个方法，提出了一些通配符来解决这些问题。</p><h2 id="泛型的通配符-、extends-和-super"><a href="#泛型的通配符-、extends-和-super" class="headerlink" title="泛型的通配符 ?、extends 和 super"></a>泛型的通配符 <code>?</code>、<code>extends</code> 和 <code>super</code></h2><p>在理解通配符之前，我们需要知道的是，通配符的发明是为了解决什么问题？至少要解决的一个问题是：容器里面放进去的是什么，取出来的就是什么。</p><p>这个问题，其实分两步，放进去，是说放进去同一种类型的东西。取出来，是说取出同一种类型的东西。或者说，用到通配符的地方应该是在不同的地方，一个地方把数据写到容器，另外一个地方把数据从容器拿出来，如果实在同一个代码块里写入和读取数据到同一个容器，应该是知道具体类型的，是不需要用到通配符的。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="? 通配符"></a><code>?</code> 通配符</h3><p><code>?</code> 通配符称为无限通配符，表示不确定或者不关心类型。</p><h3 id="extends-通配符"><a href="#extends-通配符" class="headerlink" title="extends 通配符"></a>extends 通配符</h3><p>一般称为上界通配符，表示的意思是：取值范围为 (某个类的子类, 某个类]。再想想我们之前说的，通配符要解决的问题？放进去的是什么，取出来的就应该是什么。放数据和取数据应用在不同的场景。如果我们在同一个场景，就不需要用到通配符了，因为类型是已知的。</p><p>通过上面的表述，容易推断出来 <code>&lt;? extends E&gt;</code> 的集合只能往外拿数据，因为取出来的一定是 <code>E</code> ，但是放进去的不知道是什么，可能是 <code>E</code> ，也可能是 <code>E</code> 的子类，如果允许往集合里面放东西，就不能保证放进去的是什么，拿出来的就是什么了。因为只能保证拿出来的是 <code>E</code> 。</p><p>这个特性也叫做协变。</p><h3 id="super-通配符"><a href="#super-通配符" class="headerlink" title="super 通配符"></a>super 通配符</h3><p>一般称为下界通配符，表示的意思是：取值范围为 [某个类，这个类的父类)。结合上面小节的解释，可以推断出 <code>&lt;? super S&gt;</code> 的集合只能往里面放数据，而不能从里面拿东西，为什么呢？因为 <code>&lt;? extends E&gt;</code> 解决的就是拿出来的问题啊，所以这个解决的就是放进去的问题啊，囧。里面放的是下限或者下限的子类。</p><p>这个特性也叫做逆变。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通配符与一个规则， <code>PE-CS</code>。</p><ul><li><p><code>PE</code> 简单的说，当只想从集合中获取元素，请<strong>把这个集合</strong>看成生产者，请使用&lt;? extends T&gt;，这就是 Producer extends 原则，PECS原则中的PE部分。集合生产元素后，就可以拿过来用了。</p></li><li><p><code>CS</code> 简单的说，当你仅仅想增加元素到集合，<strong>把这个集合</strong>看成消费者，请使用&lt;? super T&gt;。这就是 Consumer super 原则，PECS原则中的CS部分。集合消费元素，这样就可以往里面放了</p></li><li><p>同时作为生产者和消费者的情况不存在，因为你可以指定具体的泛型。</p></li></ul><p>参考资料：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1014635">深入理解 Java 泛型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 学习大纲总结</title>
      <link href="/android-note/2020/02/16/android/android_knowledge/"/>
      <url>/android-note/2020/02/16/android/android_knowledge/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E6%88%91%E7%9A%84-android-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">我的 Android 学习笔记</a><ul><li><a href="#java-%E5%9F%BA%E7%A1%80">Java 基础</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B">基础类型</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6">循环控制</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88">常见集合</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E9%98%9F%E5%88%97">队列</a></li><li><a href="#%E9%93%BE%E8%A1%A8">链表</a></li><li><a href="#%E6%A0%88">栈</a></li><li><a href="#%E5%AD%97%E5%85%B8">字典</a></li><li><a href="#%E6%A0%91">树</a></li></ul></li></ul></li><li><a href="#%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6">基础控件</a><ul><li><a href="#%E4%BA%94%E7%A7%8D-layout">五种 Layout</a></li><li><a href="#imageview">ImageView</a></li><li><a href="#listview">ListView</a></li><li><a href="#recyclerview">RecyclerView</a></li><li><a href="#dialog">Dialog</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6">自定义控件</a><ul><li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E8%87%AA%E5%AE%9A%E4%B9%89">属性自定义</a></li><li><a href="#canvas">Canvas</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E4%B8%8B%E5%8F%91">事件下发</a></li></ul></li><li><a href="#%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6">四大组件</a><ul><li><a href="#activity">Activity</a></li><li><a href="#service">Service</a></li><li><a href="#provider">Provider</a></li><li><a href="#broadcast">Broadcast</a></li></ul></li><li><a href="#%E5%A4%9A%E5%AA%92%E4%BD%93">多媒体</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#jetpack">Jetpack</a></li><li><a href="#%E5%8A%A8%E7%94%BB">动画</a></li><li><a href="#handler">Handler</a></li><li><a href="#asynctask">AsyncTask</a></li><li><a href="#manifast">Manifast</a></li><li><a href="#%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">跨进程通信</a></li><li><a href="#%E4%BF%9D%E6%B4%BB">保活</a></li></ul></li><li><a href="#%E4%BC%A0%E6%84%9F%E5%99%A8">传感器</a><ul><li><a href="#%E9%9C%87%E5%8A%A8">震动</a></li><li><a href="#%E6%AD%A5%E6%95%B0">步数</a></li><li><a href="#%E6%8C%87%E5%8D%97%E9%92%88">指南针</a></li></ul></li><li><a href="#framework">FrameWork</a><ul><li><a href="#ams">AMS</a></li><li><a href="#pms">PMS</a></li><li><a href="#wms">WMS</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6">常用框架</a><ul><li><a href="#%E5%9B%BE%E7%89%87">图片</a></li><li><a href="#%E7%BD%91%E7%BB%9C">网络</a></li><li><a href="#%E5%BC%82%E6%AD%A5">异步</a></li><li><a href="#%E7%BB%84%E4%BB%B6%E5%8C%96">组件化</a></li><li><a href="#%E6%8F%92%E4%BB%B6%E5%8C%96">插件化</a></li></ul></li><li><a href="#%E7%AE%97%E6%B3%95">算法</a><ul><li><a href="#%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">八种排序算法</a></li></ul></li><li><a href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90">书籍推荐</a></li></ul></li></ul><!-- /TOC --><h1 id="我的-Android-学习笔记"><a href="#我的-Android-学习笔记" class="headerlink" title="我的 Android 学习笔记"></a>我的 Android 学习笔记</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p><a href="https://blog.csdn.net/u014266877/article/details/54374867">Java 八大基本数据类型</a></p><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p><a href="https://blog.csdn.net/from_heat/article/details/82289626">Java控制语句</a></p><h3 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h3><p><a href="https://blog.csdn.net/Dante_003/article/details/79418369">java常用集合类及其区别、源码分析（一）</a></p><p><a href="https://www.jianshu.com/p/b54f1df33f84">JAVA集合框架中的常用集合及其特点、适用场景、实现原理简介</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><a href="https://www.cnblogs.com/ok932343846/p/6743699.html">Java数组的定义和使用</a></p><p><a href="https://www.cnblogs.com/mengdd/archive/2013/01/04/2844264.html">Java 数组基础</a></p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><a href="https://blog.csdn.net/u011240877/article/details/52860924">Java 集合深入理解（9）：Queue 队列</a></p><p><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html">java队列——queue详细分析</a></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><a href="https://blog.csdn.net/jianyuerensheng/article/details/51200274">【数据结构】链表的原理及java实现</a></p><p><a href="https://www.jianshu.com/p/904c2cfb5ef0">Java链表实现以及链表倒置</a></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><a href="https://blog.csdn.net/top_code/article/details/8650910">Java 数据结构之 Stack(栈)</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/53362993">java数据结构与算法之栈（Stack）设计与实现</a></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p><a href="https://www.cnblogs.com/lzq198754/p/5780165.html">Java map 详解 - 用法、遍历、排序、常用API等</a></p><p><a href="https://blog.csdn.net/qq_33642117/article/details/52049764">Java Map集合的详解</a></p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p><a href="https://www.cnblogs.com/MyStringIsNotNull/p/8279126.html">K：树、二叉树与森林之间的转换及其相关代码实现</a></p><h2 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h2><h3 id="五种-Layout"><a href="#五种-Layout" class="headerlink" title="五种 Layout"></a>五种 Layout</h3><h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h3 id="属性自定义"><a href="#属性自定义" class="headerlink" title="属性自定义"></a>属性自定义</h3><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><h3 id="事件下发"><a href="#事件下发" class="headerlink" title="事件下发"></a>事件下发</h3><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h3><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><h3 id="Manifast"><a href="#Manifast" class="headerlink" title="Manifast"></a>Manifast</h3><h3 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h3><h3 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h3><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><h3 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h3><h3 id="步数"><a href="#步数" class="headerlink" title="步数"></a>步数</h3><h3 id="指南针"><a href="#指南针" class="headerlink" title="指南针"></a>指南针</h3><h2 id="FrameWork"><a href="#FrameWork" class="headerlink" title="FrameWork"></a>FrameWork</h2><h3 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h3><h3 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h3><h3 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a>WMS</h3><h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="八种排序算法"><a href="#八种排序算法" class="headerlink" title="八种排序算法"></a>八种排序算法</h3><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

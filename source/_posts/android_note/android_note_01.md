---
seo_title: Android 开发总结笔记(一) - 泛型总结
title: Android 开发总结笔记(一) - 泛型总结
date: 2020-07-23 12:00:00
tags:
- Android
- 泛型
categories: 
- 总结笔记
---

# 泛型总结

## 泛型是什么？

一句话说就是**类型参数化**。什么意思呢？**参数化**的意思就是我们在定义的时候不知道具体的值，我们在到我们实际运行的时候才知道具体的值。类型参数化就是具体类型在定义的时候不知道，在实际运行的时候是确定的某一个类型。

## Java 是如何实现泛型的？

泛型是很多高级语言都有的特性。根据定义，泛型在运行时表示同一个类型，我们比较容易想到 `List<A>` 和 `List<B>` 用 2 个不同的 Class 表示，这个是可行的，但是 Java 由于需要兼容支持旧的代码，而且在推出泛型前就提供了容器类，这种方式(`List<A>` 和 `List<B>` 用 2 个不同的 Class)无法兼容以前的老代码，所以这个实现方法不适用。所以 Java 大佬们想了另外一种方式来实现泛型,这种方式就是`类型擦除`。

## 什么是泛型的类型擦除呢？

类型擦除就是在实际生成字节码的时候，编译器源码里面定义的 `List<A>` 变成了 `List<Object>`,源码里面定义的 `A Class` 被`擦除`了，变成了 `Object`，同时在使用的时候，会强制类型转换，把取出来的 `object` 转成 `A` 的实例去使用。这就是类型擦除。

初步看，泛型擦除好像是没什么大的问题，但是仔细想想，在强制类型转换的时候，由于会丢掉类型的一些信息，会导致一些不符合预期的事情。比如有个基类 A，和它的两个子类 B 和 C ，然后我们有下面的一段代码。

```
List<A> listA = new ArrayList<A>();
listA.add(new B()); // 错误的，
```

第二行代码是不符合预期的，因为 `listA` 里面期望放的是 `A` 而不是 `B`。 但是这个好像不太符合预期，我们有时候希望子类是可以放进容器里面的。但是如果支持这个操作的话，会发生什么呢？取出来来的是 `B` 还是 `C` ？如果不能明确，那么就没有实现“泛型”。

为了解决这个问题， Java 大佬们想了个方法，提出了一些通配符来解决这些问题。


## 泛型的通配符 `?`、`extends` 和 `super`

在理解通配符之前，我们需要知道的是，通配符的发明是为了解决什么问题？至少要解决的一个问题是：容器里面放进去的是什么，取出来的就是什么。

这个问题，其实分两步，放进去，是说放进去同一种类型的东西。取出来，是说取出同一种类型的东西。或者说，用到通配符的地方应该是在不同的地方，一个地方把数据写到容器，另外一个地方把数据从容器拿出来，如果实在同一个代码块里写入和读取数据到同一个容器，应该是知道具体类型的，是不需要用到通配符的。

### `?` 通配符

`?` 通配符称为无限通配符，表示不确定或者不关心类型。

### extends 通配符

一般称为上界通配符，表示的意思是：取值范围为 (某个类的子类, 某个类]。再想想我们之前说的，通配符要解决的问题？放进去的是什么，取出来的就应该是什么。放数据和取数据应用在不同的场景。如果我们在同一个场景，就不需要用到通配符了，因为类型是已知的。

通过上面的表述，容易推断出来 `<? extends E>` 的集合只能往外拿数据，因为取出来的一定是 `E` ，但是放进去的不知道是什么，可能是 `E` ，也可能是 `E` 的子类，如果允许往集合里面放东西，就不能保证放进去的是什么，拿出来的就是什么了。因为只能保证拿出来的是 `E` 。

这个特性也叫做协变。

### super 通配符

一般称为下界通配符，表示的意思是：取值范围为 [某个类，这个类的父类)。结合上面小节的解释，可以推断出 `<? super S>` 的集合只能往里面放数据，而不能从里面拿东西，为什么呢？因为 `<? extends E>` 解决的就是拿出来的问题啊，所以这个解决的就是放进去的问题啊，囧。里面放的是下限或者下限的子类。

这个特性也叫做逆变。

### 小结

通配符与一个规则， `PE-CS`。

- `PE` 简单的说，当只想从集合中获取元素，请**把这个集合**看成生产者，请使用<? extends T>，这就是 Producer extends 原则，PECS原则中的PE部分。集合生产元素后，就可以拿过来用了。
 
- `CS` 简单的说，当你仅仅想增加元素到集合，**把这个集合**看成消费者，请使用<? super T>。这就是 Consumer super 原则，PECS原则中的CS部分。集合消费元素，这样就可以往里面放了

- 同时作为生产者和消费者的情况不存在，因为你可以指定具体的泛型。

参考资料：

- [深入理解 Java 泛型](https://cloud.tencent.com/developer/article/1014635)